<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8" />
    <title>Editor Matematika Interaktif</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    
    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      }
    };
    </script>
    
    <script defer src="https://unpkg.com/mathlive"></script>
    <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
    <link rel="stylesheet" type="text/css" href="https://tikzjax.com/v1/fonts.css">
    <script src="https://tikzjax.com/v1/tikzjax.js"></script>

    <script src="https://sagecell.sagemath.org/static/embedded_sagecell.js"></script>

    <script>
    // Make the div with id 'Intent' a Sage cell
    sagecell.makeSagecell({inputLocation:  '#LinearSystemSolver',
                           template:       sagecell.templates.minimal,
                           evalButtonText: 'Aktifkan'});
    // Make *any* div with class 'compute' a Sage cell
    sagecell.makeSagecell({inputLocation: 'div.compute',
                           evalButtonText: 'Evaluasi'});
    </script>

    <script>
    // Make the div with id 'matriks' a Sage cell
    sagecell.makeSagecell({inputLocation:  '#matriks',
                           template:       sagecell.templates.default,
                           evalButtonText: 'ğŸ” Jalankan'});
    // Make *any* div with class 'compute' a Sage cell
    sagecell.makeSagecell({inputLocation: 'div.compute',
                           evalButtonText: 'Jalankan'});
    </script>

    <script>
    // Make the div with id 'lucu3d' a Sage cell
    sagecell.makeSagecell({inputLocation:  '#lucu3d',
                           template:       sagecell.templates.minimal,
                           evalButtonText: 'ğŸ” Aktifkan'});
    // Make *any* div with class 'compute' a Sage cell
    sagecell.makeSagecell({inputLocation: 'div.compute',
                           evalButtonText: 'aktifkan'});
    </script>

    <script>
    // Make the div with id 'sikloida' a Sage cell
    sagecell.makeSagecell({inputLocation:  '#sikloida',
                           template:       sagecell.templates.minimal,
                           evalButtonText: 'ğŸ” Aktifkan'});
    // Make *any* div with class 'compute' a Sage cell
    sagecell.makeSagecell({inputLocation: 'div.compute',
                           evalButtonText: 'aktifkan'});
    </script>

   <script>
    // Make the div with id 'pdb' a Sage cell
    sagecell.makeSagecell({inputLocation:  '#pdb',
                           template:       sagecell.templates.minimal,
                           evalButtonText: 'ğŸ” Aktifkan'});
    // Make *any* div with class 'compute' a Sage cell
    sagecell.makeSagecell({inputLocation: 'div.compute',
                           evalButtonText: 'aktifkan'});
    </script>

    <script>
    // Make the div with id 'jawab' a Sage cell
    sagecell.makeSagecell({inputLocation:  '#jawab',
                           template:       sagecell.templates.minimal,
                           evalButtonText: 'ğŸ” Aktifkan'});
    // Make *any* div with class 'compute' a Sage cell
    sagecell.makeSagecell({inputLocation: 'div.compute',
                           evalButtonText: 'aktifkan'});
    </script>
    
    <script>
    // Make the div with id 'vputar' a Sage cell
    sagecell.makeSagecell({inputLocation:  '#vputar',
                           template:       sagecell.templates.default,
                           evalButtonText: 'ğŸ” Jalankan'});
    // Make *any* div with class 'compute' a Sage cell
    sagecell.makeSagecell({inputLocation: 'div.compute',
                           evalButtonText: 'Jalankan'});
    </script>

   <script>
    // Make the div with id 'nonlin' a Sage cell
    sagecell.makeSagecell({inputLocation:  '#nonlin',
                           template:       sagecell.templates.minimal,
                           evalButtonText: 'ğŸ” Aktifkan'});
    // Make *any* div with class 'compute' a Sage cell
    sagecell.makeSagecell({inputLocation: 'div.compute',
                           evalButtonText: 'aktifkan'});
    </script>




    <script>
    // Konfigurasi SageCell
    sagecell.makeSagecell({inputLocation: '#Intent', template: sagecell.templates.minimal, evalButtonText: 'ğŸ” Aktifkan'});
    sagecell.makeSagecell({inputLocation: 'div.compute', evalButtonText: 'ğŸ” Evaluasi'});
    sagecell.makeSagecell({inputLocation: '#matriks', template: sagecell.templates.default, evalButtonText: 'ğŸ” Jalankan'});
    </script>

    <style>
        body {
            font-family: sans-serif;
            font-size: 22px;
            background-color: #d7cbcf; /* Warna latar belakang */
            max-width: 990px; /* Lebarkan area teks */
            margin: 0 0 0 155px; /* Geser konten ke kanan dengan margin kiri 50px */
            padding: 20px;
            line-height: 1.6;
        }

        .note { font-size: 1.3rem; color: #333; background:#f7f7f7; padding:0.6rem; border-radius:8px; }

        /* ... CSS Anda yang lain ... */
        .judul-kolaborasi {
          font-size: 24px;
          background-color: #e0f7fa; /* Warna latar belakang */
          color: #003366; /* Warna teks (opsional, agar kontras) */
          padding: 10px;
          border-radius: 5px;
          cursor: pointer; /* Memberikan indikasi bahwa elemen bisa diklik */
          font-weight: bold; /* Opsional: membuat teks lebih tebal */
        }
        
        h1, h2, h3 { color: #333; }
        h1 { text-align: center; margin-bottom: 30px; }
        section { margin-bottom: 25px; padding-bottom: 15px; border-bottom: 1px solid #eee; }
        section:last-child { border-bottom: none; }
        p { text-align: justify; margin-bottom: 10px; }
        ul { list-style-type: disc; margin-left: 20px; margin-bottom: 10px; }
        li { margin-bottom: 5px; }

        /* Gaya Tombol Umum */
        .btn { padding: 8px 14px; margin: 5px 5px 10px 0; background: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer; transition: background-color 0.3s ease; }
        .btn:hover { background: #0056b3; }
        .btn-small { font-size: 12px; padding: 4px 8px; margin-top: 4px; }
        .btn-delete { background: #dc3545; margin-left: 10px; }
        .btn-delete:hover { background: #c82333; }
        
        /* Gaya Blok Editor */
        .text-block, .mathlive-block, .sage-block { border: 1px solid #ddd; padding: 10px; border-radius: 8px; margin-bottom: 20px; background: #fefefe; position: relative; }
        .block-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        .block-header span { font-weight: bold; }
        textarea { width: 100%; height: 120px; font-size: 16px; margin: 5px 0; padding: 8px; border: 1px solid #ccc; border-radius: 6px; white-space: pre-wrap; }
        .preview { background: #f0f0f0; border: 1px dashed #999; padding: 10px; min-height: 40px; margin-top: 5px; }
        math-field { width: 100%; margin-top: 10px; background-color: white; color: black; border-radius: 6px; padding: 6px; font-size: 18px; }
        
        /* Gaya Tombol Horizontal Baru */
        .horizontal-menu {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin: 20px 0;
            padding: 10px;
            background-color: #f4f4f4;
            border-radius: 8px;
            border: 1px solid #ddd;
        }

        .horizontal-menu .btn {
            display: inline-block;
            margin: 0;
            padding: 10px 15px;
            background-color: #28a745;
            color: white;
            text-decoration: none;
            border-radius: 5px;
            font-size: 14px;
        }

        .horizontal-menu .btn:hover {
            background-color: #218838;
        }

        /* Gaya Info Mengambang & Tombol Lainnya */
        .floating-info { position: fixed; bottom: 360px; left: 10px; background: rgba(74, 20, 140, 0.95); color: white; padding: 10px; border-radius: 12px; font-family: Arial, sans-serif; box-shadow: 0 4px 12px rgba(0,0,0,0.4); z-index: 9999; max-width: 130px; text-align: center; }
        .floating-info h5 { margin: 0 0 4px 0; font-size: 17px; }
        .counter-number { font-size: 24px; font-weight: bold; }
        .time-display { font-size: 12px; margin-top: 6px; font-weight: bold; }
        
 /* Gaya Lainnya */
.marquee {
  width: 100%;
  overflow: hidden;
  white-space: nowrap;
  box-sizing: border-box;
  border-bottom: 2px solid #f42929;
  margin-bottom: 20px;
  font-family: 'Georgia', serif;
  font-size: 30px;
}

.marquee span {
  display: inline-block;
  padding-left: 100%;
  animation: marquee 20s linear infinite;
  font-weight: bold;
}

.marquee span .icon {
  color: #5ba1ec; /* Warna solid untuk ikon */
}

.marquee span .text {
  background: linear-gradient(to right, #cc0404, #028d02); /* Gradien yang lebih pekat */
  -webkit-background-clip: text;
  color: transparent;
  padding-left: 5px; /* Jarak antara ikon dan teks */
}

@keyframes marquee {
  0% {
    transform: translateX(0);
  }
  100% {
    transform: translateX(-150%);
  }
}
        
        hr { border: none; height: 6px; background-color: #4e0202; margin: 20px 0; }
        table { width: 100%; border-collapse: collapse; margin-top: 20px; }
        th, td { border: 3px solid #444; padding: 8px 12px; text-align: left; }
        th { background-color: #0056b3; color: white; }
        tr:nth-child(even) td { background-color: #e0f7fa; }
        tr:nth-child(odd) td { background-color: #f1f8e9; }
        .definition, .property, .example { background-color: #e0f7fa; border-left: 4px solid #0056b3; padding: 15px; margin-bottom: 20px; border-radius: 5px; }
        .proof-section { border-left: 3px solid #6a0dad; padding-left: 15px; margin-bottom: 15px; background-color: #bdf376; border-radius: 5px; }
        .proof-section p:first-child { font-weight: bold; color: #3c058f; text-align: justify; }
        .latex-math { display: block; text-align: center; font-size: 1.1em; margin: 15px 0; }

        .docs-link { font-size: 14px; margin-left: 15px; color: #007bff; text-decoration: none; }
        .docs-link:hover { text-decoration: underline; }
		
		.tooltip {
      position: relative;
      cursor: help;
    }
    .tooltip .tooltip-text {
      visibility: hidden;
      width: 250px;
      background-color: #0b0000;
      color: #f9f9f9;
      text-align: justify;
      border-radius: 6px;
      padding: 15px 10px 10px 10px;
      position: absolute;
      z-index: 1;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.1);
      opacity: 0;
      transition: opacity 0.3s;
      font-size: 12px;
      line-height: 1.4;
    }
    .tooltip:hover .tooltip-text {
      visibility: visible;
      opacity: 1;
    }
    /* Tambahan untuk tombol close di tooltip */
    .close-btn {
      position: absolute;
      top: 5px;
      right: 8px;
      font-size: 18px;
      cursor: pointer;
      background: none;
      border: none;
      color: #f4e5e5;
      padding: 0;
    }

    .card {
      background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0));
      border: 1px solid var(--line);
      border-radius: 18px;
      padding: 18px 18px 14px;
      box-shadow: 0 10px 30px rgba(0,0,0,.25);
    }

</style>
   

</head>
<body>

<div class="floating-info">
    <h5>ğŸŒPengunjung:</h5>
    <div class="counter-number" id="visitor-count">0</div>
    <div class="time-display" id="time-now">Memuat waktu...</div>
</div>

<script>
    let count = localStorage.getItem("visitorCount");
    if (count === null) {
        count = 0;
    }
    count++;
    localStorage.setItem("visitorCount", count);
    document.getElementById("visitor-count").innerText = count;

    function updateTime() {
        const now = new Date();
        const hari = ["Minggu","Senin","Selasa","Rabu","Kamis","Jumat","Sabtu"];
        const bulan = ["Januari","Februari","Maret","April","Mei","Juni","Juli","Agustus","September","Oktober","November","Desember"];
        const teks = `${hari[now.getDay()]}, ${now.getDate()} ${bulan[now.getMonth()]} ${now.getFullYear()} ` +
            `${String(now.getHours()).padStart(2,'0')}:${String(now.getMinutes()).padStart(2,'0')}:${String(now.getSeconds()).padStart(2,'0')}`;
        document.getElementById("time-now").innerText = teks;
    }
    updateTime();
    setInterval(updateTime, 1000);  
</script>

<div class="floating-image" style="position: fixed; bottom: 230px; left: 10px; z-index: 9999;">
  <a href="https://sites.google.com/view/rumahmath/home" target="_blank">
    <img src="https://i.imgur.com/ycBaXip.jpeg" alt="Rumah Matematika"
         style="width: 150px; border-radius: 13px; box-shadow: 0 4px 13px rgba(0,0,0,0.3);">
  </a>
</div> 

<div class="marquee"><span>ğŸ“„ Editor LaTeX / Markdown Dinamis + ğŸ’» SageMath Cell Interaktif + âœï¸ MathLive Editor</span></div>

<h2><b>Pengembangan Antarmuka Editor Matematika Dinamis Berbasis HTML</b></h2>
<p style="font-size:20px; align: justify;">
(This work is grounded in <b>collaboration</b> and <b>discussion</b> with <b>ChatGPT, Deep Seek</b> and <b>Google-Gemini</b>)
</p>

<div class="block">
    <h2>Abstrak</h2>
    <p align="justify" style="font-size: 18px;">
        Penggunaan teknologi web untuk pembelajaran matematika interaktif semakin relevan dalam era digital. Artikel ini membahas perancangan dan implementasi antarmuka berbasis <b>HTML</b> yang memungkinkan pengguna untuk menuliskan, merender, dan mengevaluasi ekspresi matematika secara dinamis. Sistem ini mengintegrasikan tiga komponen utama: <b>\(\LaTeX\) editor</b> dengan pratinjau langsung, <b>MathLive</b> sebagai editor ekspresi matematis berbasis <b>WYSIWYG</b>, serta <b>SageMath Cell</b> sebagai lingkungan komputasi simbolik. Semua komponen dirancang dalam satu dokumen HTML responsif, tata letak fleksibel, dan penambahan elemen secara dinamis. Hal ini tentunya sangat mendukung untuk proses pembelajaran matematika secara interaktif yang tidak hanya mengeksplorasi kemampuan teoritis saja, tetapi dapat mewujudkan menjadi satu kesatuan yang tak-terpisah: <b>teori, aplikasi (real problem) dan komputasi</b>. Tentunya, ini adalah wujud nyata dari suatu <b>Laboratorium Matematika Interaktif Dinamis gratis (murah) yang hanya membutuhkan akses internet</b>. Selain aspek teknis, pendekatan ini sejalan dengan paradigma pembelajaran matematika modern yang menekankan keterpaduan antara tiga aspek fundamental: <b>konseptual-teoritis, aplikatif-konstekstual, dan komputasional</b>. Implementasi seperti ini sangat relevan, khususnya untuk pembelajaran topik-topik seperti: <b>manipulasi simbolik, evaluasi ekspresi matematis, visualisasi grafik fungsi, serta eksplorasi numerik dan simbolik</b> pada sistem persamaan linear maupun non-linear secara langsung di peramban (browser).
    </p>
    <div align="right">
        <p><b>
        <span style="text-align: right; display: block;">Ù‚ÙØ§Ù„ÙÙˆØ§ÛŸ Ø³ÙØ¨Ù’Ø­ÙÙ€Ù°Ù†ÙÙƒÙ Ù„ÙØ§ Ø¹ÙÙ„Ù’Ù…Ù Ù„ÙÙ†ÙØ¢ Ø¥ÙÙ„ÙÙ‘Ø§ Ù…ÙØ§ Ø¹ÙÙ„ÙÙ‘Ù…Ù’ØªÙÙ†ÙØ¢ Û– Ø¥ÙÙ†ÙÙ‘ÙƒÙ Ø£ÙÙ†ØªÙ Ù±Ù„Ù’Ø¹ÙÙ„ÙÙŠÙ…Ù Ù±Ù„Ù’Ø­ÙÙƒÙÙŠÙ…Ù
        <br>
        Surat Al-Baqarah (2:32)
        </span>
        </b>
        </p>
    </div>
    <hr>
    <p align="justify">
    <b>Catatan:</b> Sebagian besar materi yang disajikan hasil kerjasama penulis dengan <b>berdiskusi</b> mennggunakan "<b>ChatGPT</b>", "<b>DeepSeek</b>" dan "<b>Google-Gemini</b>" serta pemanfaatan "<b>komputasi awan</b>" sehingga tercipta dan tersajinya "<b>laboratorium virtual Matematika berbasis web</b>" ini.
    </p>
    <hr>
    
    <h3><a href="https://www.youtube.com/watch?v=loGUCC4XG98" target="blank"><b>Matematika Bahasa Alam Semesta</b></a></h3>
       <p>
        Seperti bintang yang berbisik lewat cahaya, dan planet yang menari dalam irama tak kasatmata,  
        matematika hadir sebagai bahasa sunyi yang menyatukan keindahan semesta.  
        Ia bukan sekadar hitungan, melainkan puisi yang ditulis dalam angka -  
        menyingkap rahasia alam, dari butiran debu hingga galaksi tak bertepi.
      </p>
    <hr>

    <h3><a href="https://www.youtube.com/watch?v=On_ymad-nPw" target="blank"><b>Kekuatan Matematika</b></a></h3>
      <p>
        Di balik simbol dan rumus yang tegas bersemayam daya yang mampu mengguncang dunia.  
        Setiap persamaan adalah pedang, setiap teori adalah jembatan, dan setiap matriks tersusun rapi - elegan -  
        menjadi bukti bahwa matematika adalah kekuatan yang tak sekadar menjelaskan, tetapi juga mencipta dan mengubah.
        "Semua tersusun rapi, elegan - sebuah argumen yang menenun dunia menjadi mungkin."
      </p>
</div>
<hr>

<div class="container">
    <h2><b>0. Satu Kesatuan Yang Tak-terpisahkan</b></h2>
    <hr>
    
    <section>
    <details> 
       <summary class="judul-kolaborasi">
       âœ¨ <b>Lingkaran Segitiga Matematika sebagai Fondasi Baru Literasi Digital dan Etika AI</b>
      </summary>
    
     <br> 
     <center>
       <img src="https://raw.githubusercontent.com/Subiono2021/Gambar/main/SegitigaMathB.png" 
        alt="Segitiga Math" width="200">
       <p style="font-size:18px; text-align:center;" >
        Gambar: "<b>Segitiga Matematika sebagai Fondasi Baru Literasi Digital dan Etika AI</b>"
       </p>
     </center>
     <p align="justify">
        Gambar menunjukkan bahwa diagram "<b>Lingkaran Segitiga Matematika</b>" merupakan makna atau definisi dari matematika.
        Yaitu, "<b>matematika adalah teori, aplikasi dan komputasi yang menjadi satu kesatuan tak-terpisahkan</b>".
     </p>

     <h3><b> 1. Pendahuluan</b></h3>
     <p align="justify">
    Matematika sering didefinisikan dengan berbagai cara: sebagai studi pola dan struktur, bahasa universal ilmu pengetahuan, 
    atau sistem deduksi logis. Namun, definisi-definisi tersebut cenderung hanya menekankan salah satu aspeknya. 
    Gagasan <b>Lingkaran Segitiga Matematika</b> menawarkan definisi ringkas, padat, visual, dan menyeluruh, yang memandang 
    matematika sebagai kesatuan tiga unsur yang saling terkait: <b>Teori</b>, <b>Aplikasi</b>, dan <b>Komputasi</b>.
    </p>

<p align="justify">
    Seperti halnya teori, aplikasi, dan komputasi yang tak-terpisahkan dalam matematika, 
    literasi digital dan etika AI juga merupakan satu kesatuan integral dalam kehidupan modern. 
    <b>Literasi digital</b> memberikan kemampuan memahami, menganalisis, dan memanfaatkan teknologi informasi.
    Literasi digital adalah kemampuan untuk memahami, menggunakan, dan mengelola teknologi digital secara bijak, 
    kritis, dan bertanggung jawab. Tidak hanya soal keterampilan teknis mengoperasikan perangkat dan aplikasi, 
    tetapi juga mencakup kemampuan menilai kredibilitas informasi, melindungi privasi dan keamanan data, serta 
    berkomunikasi secara etis di ruang digital. Dalam konteks perkembangan AI dan etika digital, literasi digital 
    membantu individu menyadari dampak penggunaan teknologi terhadap kehidupan sosial, budaya, ekonomi, dan moral. 
    Orang yang literat digital mampu memilah informasi, menghindari hoaks, menjaga jejak digital, serta memanfaatkan 
    teknologi untuk hal-hal yang produktif, kreatif, dan bermanfaat bagi masyarakat.
    Sedangkan <b>etika AI</b> memastikan bahwa pemanfaatan teknologi tersebut tidak keluar dari nilai-nilai kemanusiaan, 
    keadilan, dan tanggung jawab sosial. Literasi digital tanpa etika AI dapat menimbulkan disinformasi, manipulasi, 
    bahkan dehumanisasi; sebaliknya, etika AI tanpa literasi digital tidak mungkin dipahami apalagi diterapkan 
    secara efektif.
</p>

<p align="justify">
    Dalam konteks inilah, <b>Lingkaran Segitiga Matematika</b> dapat dijadikan <i>fondasi epistemologis</i> baru: 
    teori merepresentasikan prinsip dasar dan nilai, aplikasi mencerminkan penerapan teknologi digital di masyarakat, 
    dan komputasi menjadi sarana utama pengolahan data serta pengembangan AI. 
    Dengan cara pandang ini, literasi digital dan etika AI tidak diposisikan sebagai dua disiplin yang terpisah, 
    tetapi sebagai kelanjutan logis dari tradisi keilmuan matematika yang telah bertransformasi di era digital. 
</p>

     <hr>
     <h3><b> 2. Konsep Lingkaran Segitiga Matematika </b></h3>
     <ol align="justify">
       <li> <b>Teori</b> - Kerangka konseptual yang dibangun melalui logika dan pembuktian.</li>
       <li> <b>Aplikasi</b> - Penghubung antara konsep dan realitas, menjawab kebutuhan praktis manusia.</li>
       <li> <b>Komputasi</b> - Sarana modern untuk mengeksplorasi, menguji, dan mengimplementasikan teori secara efektif.</li>
     </ol>

     <h4><b> 2.1 Hubungan Timbal Balik </b></h4>
     <ul align="justify">
      <li>Tidak ada hierarki antara ketiga unsur tersebut; mereka setara dan saling memperkaya.</li>
      <li>Teori memicu lahirnya aplikasi; aplikasi memunculkan kebutuhan teori baru; komputasi mempercepat 
          dan memperluas keduanya melalui algoritma-algoritma yang terbentuk.</li>
     </ul>

     <h4><b> 2.2 Dimensi Kontemporer </b></h4>
<p align="justify">
   Dalam era digital, <b>Lingkaran Segitiga Matematika</b> tidak hanya relevan secara teoretis, 
   tetapi juga menjadi fondasi dalam memahami literasi digital dan etika kecerdasan buatan (AI). 
   <b>Teori</b> menyediakan prinsip dasar dan kerangka berpikir kritis untuk menilai teknologi digital. 
   <b>Aplikasi</b> memungkinkan matematika terwujud dalam bentuk perangkat lunak, big data, hingga sistem AI yang digunakan masyarakat. 
   <b>Komputasi</b> menghadirkan kekuatan pemrosesan algoritmik, yang menjadi inti pembelajaran mesin dan kecerdasan buatan modern.
</p>
<p align="justify">
   Hubungan timbal balik ini semakin nyata ketika dikaitkan dengan literasi digital dan etika AI: 
   literasi digital menuntut pemahaman <i>teori</i> informasi, keterampilan dalam <i>aplikasi</i> teknologi, 
   serta kecakapan memanfaatkan <i>komputasi</i>. Sementara itu, etika AI hadir sebagai <b>penyeimbang normatif</b>, 
   memastikan teori tidak lepas dari nilai kemanusiaan, aplikasi tidak menyimpang dari tujuan sosial, 
   dan komputasi tidak digunakan secara manipulatif. 
</p>

     <hr>

     <h3><b> 3. Landasan Historis </b></h3>
     <p align="justify">
       Sepanjang sejarah, <b>tidak ada teori matematika yang lahir tanpa asal-usul</b>. Setiap teori:
     </p>
     <ul align="justify">
      <li>Berakar pada kebutuhan praktis (pengukuran, perdagangan, astronomi, arsitektur, navigasi).</li>
      <li>Atau berasal dari pengembangan internal matematika yang akarnya tetap berhubungan dengan realitas sebelumnya.</li>
     </ul>
     <p align="justify">
        Bahkan teori yang tampak murni abstrak, seperti teori grup atau geometri non-Euclid, lahir dari masalah konkret 
        pada masanya. Fakta ini menguatkan bahwa matematika memang membentuk satu ekosistem utuh antara teori, aplikasi, 
        dan metode perhitungannya.
     </p>
     <p align="justify">
   Jika ditarik ke masa kini, pola historis tersebut tetap berulang: 
   kebutuhan praktis melahirkan teori baru, lalu teori tersebut mendorong inovasi teknologi. 
   Misalnya, kalkulus yang lahir dari persoalan astronomi dan fisika klasik kini menjadi dasar 
   dalam <i>machine learning</i> dan analisis data besar. Teori probabilitas yang dahulu berkembang 
   untuk perjudian dan asuransi, kini menjadi landasan dalam algoritma kecerdasan buatan. 
</p>
<p align="justify">
   Dengan demikian, <b>literasi digital</b> dapat dipandang sebagai kelanjutan dari kemampuan manusia 
   menggunakan matematika untuk memahami dan menguasai teknologi baru. Sementara itu, 
   <b>etika AI</b> hadir sebagai refleksi modern dari tradisi filosofis matematika: 
   memastikan bahwa perkembangan teori, aplikasi, dan komputasi tidak sekadar memenuhi ambisi teknis, 
   melainkan tetap berpijak pada nilai-nilai kemanusiaan. 
   Sejarah matematika dengan jelas menunjukkan bahwa ilmu ini selalu berhubungan dengan realitas sosial, 
   dan pada era digital, realitas itu mencakup tanggung jawab etis dalam penggunaan teknologi.
</p>
     <hr>

     <h3><b> 4. Dimensi Filosofis </b></h3>
     <p align="justify">
       Lingkaran Segitiga Matematika juga selaras dengan tiga kerangka filsafat ilmu:
     </p>
     <ol align="justify">
      <li> <b>Etimologi</b> - Kata â€œmatematikaâ€ berasal dari Yunani <i>mathÄ“matiká¸—</i>, yang berarti â€œilmu pengetahuanâ€ 
           atau â€œpembelajaranâ€. Segitiga ini menghidupkan kembali makna menyeluruh tersebut.
      </li>
      <li> <b>Ontologi</b> - Menjawab pertanyaan: Apa hakikat keberadaan matematika dalam lingkaran segitiga matematika ini?</b>
         <ul align="justify">
             <li> Menegaskan bahwa matematika bukan hanya kumpulan simbol atau aturan formal, melainkan memiliki eksistensi 
                  sebagai struktur realitas yang mendasari fenomena alam, pikiran, dan teknologi.
             </li>
             <li> Dalam lingkaran segitiga matematika, Ontologi memposisikan matematika sebagai sesuatu yang hadir 
                  sekaligus di dunia ide (abstraksi) dan dunia nyata (aplikasi).
             </li>
             <li> Ontologi menjamin kesatuan: segitiga (struktur dasar matematika) yang membentuk lingkaran 
                  (keseluruhan kehidupan dan pengetahuan).
             </li>
         </ul>
      </li>
      <li> <b>Epistemologi</b> - Menjawab pertanyaan: <b>Bagaimana pengetahuan matematika diperoleh?</b>
         <ul align="justify">
           <li>Teori â†’ deduksi logis. </li>
           <li>Aplikasi â†’ validasi di dunia nyata.</li>
           <li>Komputasi â†’ eksplorasi dan verifikasi modern.</li>
         </ul>
      </li>
      <li> <b>Aksiologi</b> - Menjawab pertanyaan: <b>Untuk apa matematika digunakan?</b>
           <ul align="justify">
              <li>Menegaskan nilai guna matematika bagi kehidupan manusia, bukan hanya untuk kepuasan intelektual.</li>
           </ul>
      </li>
     </ol>
     <p align="justify">
         Empat kerangka filsafat ini dapat dipahami sebagai lingkar luar yang 
         menyelubungi Segitiga Matematika. <b>Etimologi</b> mengingatkan bahwa sejak awal 
         matematika dimaknai sebagai â€œilmu pengetahuan secara menyeluruhâ€, bukan sekadar hitungan. 
         <b>Epistemologi</b> menegaskan bahwa matematika bukan hanya hasil abstraksi semata, 
         melainkan diperoleh dari kombinasi logika, pengalaman nyata, dan eksplorasi komputasi modern. 
         <b>Ontologi</b> menegaskan hakikat keberadaan matematika sebagai struktur yang nyata dalam alam, 
         abstrak dalam pikiran, dan menyatu dalam kehidupan, sehingga menjadi dasar bagi pengetahuan dan penerapan. 
         <b>Aksiologi</b> memastikan bahwa keberadaan matematika tidak berhenti pada kepuasan intelektual, 
         melainkan memberi manfaat nyata, baik untuk ilmu, teknologi, maupun kesejahteraan manusia. 
      </p>

      <p align="justify">
         Dalam konteks abad digital, filosofi ini menemukan bentuk barunya. 
         <b>Etimologi</b> dapat dipandang sebagai dasar literasi digital, karena memahami â€œilmu pengetahuanâ€ 
         kini mencakup kemampuan membaca, menulis, dan berpikir kritis di ruang digital. 
         <b>Ontologi</b> menegaskan hakikat keberadaan data, informasi, dan realitas virtual, 
         yaitu bagaimana entitas digital (seperti algoritma, basis data, atau ruang siber) 
         dipahami sebagai bagian dari struktur pengetahuan dan kehidupan manusia. 
         <b>Epistemologi</b> berhubungan erat dengan proses pembelajaran mesin dan kecerdasan buatan, 
         yang meniru cara manusia memperoleh pengetahuan melalui data, deduksi, dan verifikasi. 
         <b>Aksiologi</b> menjadi landasan <b>etika AI</b>, yaitu bagaimana teknologi berbasis matematika dan komputasi 
         digunakan dengan tanggung jawab moral, keadilan, dan kemanusiaan. 
      </p>

      <p align="justify">
         Dengan demikian, dimensi filosofis Lingkaran Segitiga Matematika tidak hanya relevan untuk 
         memahami matematika secara klasik, tetapi juga menjadi peta konseptual bagi mahasiswa dan peneliti 
         dalam menghadapi tantangan literasi digital dan etika AI di era transformasi teknologi.
      </p>

      <h4></4> Contoh-contoh Real</h4>
      <p align="justify">
          <b>Contoh 1: Chatbot Pendidikan</b>
          <ul align="justify">
             <li> <b>Ontologi</b>: Pertanyaan mahasiswa (sebagai real problem komunikasi).</li>
             <li> <b>Epistemologi</b>: AI mengakses basis data pengetahuan dan memberikan jawaban.</li>
             <li> <b>Aksiologi</b>: Jawaban AI harus akurat, jelas, dan tidak menyesatkan; nilai pendidikan 
                   lebih diutamakan daripada sekadar efisiensi teknis.
             </li>
          </ul>
          <b> Contoh 2: Sistem Rekomendasi (YouTube, TikTok)</b>
          <ul align="justify">
             <li> <b>Ontologi</b>: Data perilaku pengguna (klik, waktu tonton).</li>
             <li> <b>Epistemologi</b>: Algoritma machine learning yang membangun profil pengguna.</li>
             <li> <b>Aksiologi</b>: Apakah sistem diarahkan untuk meningkatkan <i>engagement</i> semata, atau 
                   juga memperhatikan kesehatan mental pengguna dengan menghindari konten adiktif?
             </li>
          </ul>
          <b>Contoh 3: Penggunaan Deepfake</b>
          <ul align="justify">
             <li><b>Ontologi</b>: Representasi visual (gambar/video hasil generasi AI).</li>
             <li><b>Epistemologi</b>: Teknologi GAN (Generative Adversarial Networks).</li>
             <li><b>Aksiologi</b>: Etika penggunaan, apakah untuk seni/hiburan, atau penyebaran hoaks dan 
                  manipulasi politik?
             </li>
          </ul>
      </p>
     <hr>

     <h3><b> 5. Misi dan Manfaat </b></h3>
     <p align="justify">
       Lingkaran Segitiga Matematika adalah <b>peta jalan</b> untuk mempelajari, mengajarkan, dan mengembangkan matematika. 
       Dengan memandang matematika sebagai kesatuan dinamis, siapa pun dapat:
     </p>
     <ul align="justify">
      <li> Memahami hubungan antara abstraksi dan kenyataan.</li>
      <li> Mengalirkan ilmu untuk memecahkan masalah nyata.</li>
      <li>Mendedikasikan pengetahuan demi kemajuan dan kesejahteraan bersama.</li>
     </ul>
     <hr>

     <h3><b> 6. Visualisasi </b></h3>
     <p align="justify">
        Diagram filosofis Lingkaran Segitiga Matematika dapat digambarkan sebagai segitiga sama sisi berisi <b>Teori</b>, 
        <b>Aplikasi</b>, dan <b>Komputasi</b>, dilingkari oleh lapisan luar berisi <b>Ontologi</b>, <b>Epistemologi</b>, 
        dan <b>Aksiologi</b>. Hubungan antar titik segitiga digambarkan dengan panah dua arah, menandakan hubungan 
        timbal balik dan kedudukan yang setara.
     </p>
     <hr>

     <h3><b> 7. Penutup </b></h3>
     <p align="justify">
         Lingkaran Segitiga Matematika bukan sekadar klasifikasi bidang, melainkan <b>cara pandang utuh</b> terhadap 
         matematika di abad modern. Ia memadukan kekuatan tradisi ilmiah dengan relevansi praktis dan teknologi, menawarkan 
         jalan kemudahan dan kemanfaatan bagi mereka yang mendedikasikan ilmunya untuk orang lain.
     </p>
     <p align="justify">
         Konsep â€œLingkaran Segitiga Matematikaâ€ menawarkan paradigma baru dalam memahami keterkaitan antara filsafat, 
         matematika, literasi digital, dan etika AI. Dengan pendekatan ini, mahasiswa dapat membangun kerangka berpikir 
         yang holistik, kritis, dan bertanggung jawab, sehingga teknologi digital dan AI benar-benar menjadi sarana untuk 
         menyelesaikan real problem dunia nyata secara beretika.
     </p>
   </details>
   </section>
</div>
<hr>

<div class="container">
<h2><b>1. Pendahuluan</b></h2>
<hr>
    
<section>
<details> 
<summary class="judul-kolaborasi">
âœ¨ Kolaborasi Matematis dengan <b>SageMath, \(\LaTeX\), dan MathLive</b>
</summary>
<p align="justify">
Kemajuan <b>teknologi web</b> telah memungkinkan <b>implementasi sistem komputasi matematis interaktif</b> yang dapat 
diakses <b>luas oleh akademisi</b>, <b>pendidik</b>, maupun <b>peneliti</b>. Salah satu platform open-source terkemuka 
adalah <b>SageMath</b>, yang mengintegrasikan <b>sistem matematika komputer</b> dalam antarmuka ramah pengguna 
<b>berbasis web</b>.
</p>
<p align="justify">
Kombinasi antara <b>SageMath</b>, <b>editor \(\LaTeX\)</b> untuk dokumentasi matematis yang presisi, serta <b>MathLive</b> 
untuk penulisan ekspresi matematika <b>WYSIWYG</b>, menciptakan <b>ekosistem belajar</b> dan <b>riset yang efektif</b>, 
<b>fleksibel</b>, dan <b>kolaboratif</b>.
<br>
<br>
Artikel ini menguraikan kerangka teoretis hingga implementasi praktis, mencakup:
</p>
<ul align="justify">
<li>âœ”ï¸ Ruang Vektor dan Operasi Dasar.</li> 
<li>âœ”ï¸ Matriks dan Transformasi Linier.</li> 
<li>âœ”ï¸ Nilai dan Vektor Eigen.</li> 
<li>âœ”ï¸ Aljabar Tensor sebagai Representasi dalam Komputasi Kuantum.</li>
<li>âœ”ï¸ Implementasi Interaktif berbasis Web dengan SageMath dan MathLive.</li>
</ul>
<hr>	
<h3> 1.1 Motivasi</h3>
<p align="justify">
Perkembangan ilmu pengetahuan dan teknologi saat ini menuntut adanya media pembelajaran serta 
laboratorium komputasi yang bersifat <b>terbuka, mudah diakses, dan interaktif</b>. Aljabar Linier, 
sebagai fondasi dalam banyak disiplin seperti machine learning, grafik komputer, dan komputasi 
kuantum, memerlukan sarana eksplorasi yang tidak hanya teoritis tetapi juga praktis.
</p>
<p align="justify">
Namun, penggunaan perangkat lunak komputasi matematis canggih seperti <b>MATLAB, Mathematica</b>, 
atau software desktop lainnya seringkali memerlukan instalasi lokal, lisensi tertutup, dan 
infrastruktur komputasi yang terbatas pada perangkat tertentu. Kondisi ini menjadi penghalang 
bagi banyak pelajar, pendidik, maupun peneliti yang membutuhkan akses fleksibel dan kolaboratif.
</p>
<p align="justify">
Oleh karena itu, diperlukan sebuah <b>laboratorium virtual berbasis web</b> yang memanfaatkan 
<b>komputasi awan</b> agar pengguna dapat berinteraksi secara langsung, melakukan perhitungan 
simbolik dan numerik, serta memvisualisasikan konsep Aljabar Linier kapan pun dan di mana 
pun tanpa batasan platform.
</p>
<p align="justify">
Dengan mengintegrasikan <b>SageMath</b> sebagai mesin komputasi open-source, 
<b>editor \(\LaTeX\) dengan pratinjau <i>real-time</i></b> untuk dokumentasi matematis yang presisi, 
serta <b>MathLive</b> sebagai editor ekspresi matematis berbasis <b>WYSIWYG</b>, sistem ini diharapkan mampu:
</p>
<ul align="justify">
<li> Memberikan kemudahan dalam memahami dan memanipulasi objek-objek Aljabar Linier secara komputasi.</li>
<li>Menyediakan lingkungan belajar yang ramah pengguna, interaktif, dan modern.</li>
<li>Menjembatani kebutuhan antara pembelajaran fundamental dan aplikasi tingkat lanjut seperti aljabar tensor 
untuk komputasi kuantum.</li>
</ul>
<p align="justify">
Laboratorium web ini tidak hanya memfasilitasi pembelajaran individual tetapi juga sangat potensial untuk 
pengajaran kolaboratif dan penelitian terbuka berbasis cloud.ğŸš€
</p>
<hr>	
<h3>1.2 Kontribusi Utama</h3>
<p align="justify">
Penelitian dan pengembangan yang disajikan dalam artikel ini memberikan kontribusi signifikan 
terhadap bidang <b>pembelajaran</b>, <b>eksplorasi</b>, dan <b>komputasi Aljabar Linier</b>, khususnya melalui integrasi 
<b>teknologi berbasis web</b> dan <b>komputasi awan</b>. Adapun kontribusi utama dari karya ini dapat dirangkum 
sebagai berikut:
</p>
<ol align="justify">
<li> <b>Perancangan Laboratorium Web Interaktif untuk Aljabar Linier:</b>
   Sistem yang dikembangkan merupakan laboratorium virtual berbasis web yang memungkinkan pengguna 
   untuk melakukan eksplorasi konsep-konsep Aljabar Linier secara interaktif tanpa memerlukan instalasi lokal. 
   Fasilitas ini memanfaatkan komputasi awan sehingga dapat diakses melalui perangkat apa pun dengan koneksi internet.
</li>
<li> <b>Integrasi SageMath sebagai Mesin Komputasi Open-Source:</b>
   Dengan mengintegrasikan SageMath, pengguna dapat melakukan komputasi simbolik dan numerik secara 
   langsung melalui antarmuka web. Hal ini mencakup perhitungan matriks, determinan, nilai dan vektor eigen, 
   serta transformasi linier lainnya yang menjadi inti dalam Aljabar Linier.
</li>
<li> <b>Penyediaan Editor \(\LaTeX\) dengan Pratinjau <i>Real-Time</i>:</b>
   Untuk mendukung penulisan matematis yang presisi dan profesional, sistem ini dilengkapi dengan 
   editor \(\LaTeX\) yang dapat menampilkan pratinjau langsung. Fitur ini mempermudah dokumentasi, pembuatan catatan, 
   serta pembuatan laporan ilmiah tanpa perlu perangkat lunak tambahan.
</li>
<li> <b>Implementasi MathLive sebagai Editor Ekspresi Matematis WYSIWYG:</b>
   Sistem juga menyediakan editor ekspresi matematis berbasis MathLive, yang memungkinkan pengguna 
   mengetik formula matematika dengan antarmuka visual intuitif. Fitur ini sangat bermanfaat bagi 
   pengguna yang belum familiar dengan sintaks \(\LaTeX\) tetapi tetap menginginkan dokumentasi ekspresi matematis yang rapi.
</li>
<li> <b>Pengenalan Aljabar Tensor untuk Komputasi Kuantum:</b>
   Selain cakupan dasar seperti ruang vektor, matriks, dan transformasi linier, sistem ini 
   memperkenalkan aljabar tensor sebagai alat representasi struktural dalam komputasi kuantum. 
   Hal ini memberikan wawasan awal tentang bagaimana konsep Aljabar Linier diperluas ke ranah 
   sistem multi-partikel dan komputasi tingkat lanjut.
</li>
<li> <b>Konsep Terbuka dan Fleksibel Berbasis Komputasi Awan:</b>
   Seluruh komponen sistem didesain terbuka, fleksibel, dan berbasis cloud, sehingga dapat 
   digunakan secara lintas platform tanpa kendala lisensi komersial atau ketergantungan pada perangkat 
   keras tertentu. Konsep ini mendukung prinsip pendidikan terbuka dan kolaborasi lintas institusi.
</li>
</ol>
<p align="justify">
Dengan kontribusi-kontribusi tersebut, sistem ini diharapkan dapat menjadi alternatif inovatif 
dalam pembelajaran, penelitian, maupun eksplorasi mandiri terkait Aljabar Linier, sekaligus 
mendorong pemahaman konsep matematis yang lebih aplikatif menuju era komputasi kuantum.
</p>
</details> 
</section>

    <div class="horizontal-menu">
            <button class="btn" onclick="addTextBlock(this)">â• Teks LaTeX</button>
            <button class="btn" onclick="addMathliveBlock(this)">â• MathLive</button>
            <button class="btn" onclick="addSageCell(this)">â• SageMath</button>
            <button class="btn save-all-btn" id="saveBtn0">ğŸ’¾ Simpan Semua</button>
            <button class="btn import-btn" data-target="importFile0">ğŸ“‚ Impor File</button>
            <input type="file" id="importFile0" accept=".json" style="display:none" />
            <button class="btn" onclick="localStorage.clear(); alert('Data lokal dibersihkan!')">ğŸ§¹ Bersihkan Data</button>
        </div>
</div>     
<hr>


<div class="container">
    <h2><b>2. Panduan Penggunaan: Laboratorium Matematika Komputasi Interaktif Dinamis</b></h2>
    <hr>
    <section>
        <details>
            <summary class="judul-kolaborasi">
                <b>âœ¨ Selamat Datang</b>
            </summary>     
            <section>
                <p align="justify">
                Laboratorium <b>Komputasi Aljabar Linier interaktif</b> ini adalah sebuah platform yang dirancang 
                untuk memfasilitasi pembelajaran, eksperimen, dan penyelesaian masalah matematis secara dinamis 
                dalam konteks Aljabar Linier. Anda akan menemukan integrasi berbagai alat yang mendukung penanganan 
                notasi, input, dan komputasi matematika yang spesifik untuk bidang ini.
                </p>
                <p align="justify">
                Seluruh sesi kerja Anda, termasuk setiap blok dan konten di dalamnya, akan disimpan secara 
                otomatis di browser Anda. Fitur ini memungkinkan Anda untuk melanjutkan pekerjaan tanpa 
                kehilangan data meskipun setelah menutup atau memuat ulang halaman. Selain itu, Anda memiliki 
                opsi untuk menyimpan seluruh sesi kerja Anda ke dalam berkas atau memuatnya kembali di kemudian 
                hari untuk fleksibilitas maksimal.
                </p>
                <p align="justify">
                Anda dapat mengikuti perkembangan/informasi yang kita tulis tekan tombol ikon tersaji di bagian kiri 
                <a href="https://sites.google.com/view/rumahmath/home" target="_blank"><button><b><mark>Rumah Matematika</mark></b></button></a>.
                </p>
            </details>
        </section>

        <div class="horizontal-menu">
            <button class="btn" onclick="addTextBlock(this)">â• Teks LaTeX</button>
            <button class="btn" onclick="addMathliveBlock(this)">â• MathLive</button>
            <button class="btn" onclick="addSageCell(this)">â• SageMath</button>
            <button class="btn save-all-btn" id="saveBtn1">ğŸ’¾ Simpan Semua</button>
            <button class="btn import-btn" data-target="importFile1">ğŸ“‚ Impor File</button>
            <input type="file" id="importFile1" accept=".json" style="display:none" />
            <button class="btn" onclick="localStorage.clear(); alert('Data lokal dibersihkan!')">ğŸ§¹ Bersihkan Data</button>
        </div>
    </div>     
    <hr>

<div class="container">
    <h2><b>3. Menu Utama: Membuat Blok Baru</b></h2>
    <hr>
    <section>
        <details>
            <summary class="judul-kolaborasi">
                âœ¨  <b>Menu Utama: Membuat Blok Baru</b> 
            </summary>     
            <p>Di akhir setiap bahasan, Anda akan melihat menu yang berisi tombol-tombol untuk 
            menambahkan jenis blok yang berbeda ke area kerja utama Anda:</p>
            <ul align="justify">
            <li>
            <strong>â• Teks \(\LaTeX\)</strong>: Klik ini untuk menambahkan blok di mana Anda dapat menulis teks 
            biasa dan notasi matematika menggunakan bahasa \(\LaTeX\). Ini ideal untuk membuat catatan, soal, atau 
            penjelasan yang terstruktur dan terlihat profesional.
            </li>
            <li>
            <strong>â• MathLive</strong>: Tombol ini menambahkan blok dengan editor matematika visual. Anda bisa 
            memasukkan rumus dan ekspresi matematika dengan mudah, seperti mengetik di editor persamaan, tanpa 
            perlu tahu sintaks \(\LaTeX\).
            </li>
            <li>
            <strong>â• SageMath</strong>: Ini adalah blok paling canggih untuk melakukan perhitungan matematika. 
            Anda dapat menulis dan menjalankan kode program menggunakan SageMath (berbasis Python) untuk memecahkan 
            masalah aljabar, kalkulus, statistik, dan banyak lagi. Perhitungan ini dilakukan di "cloud" 
            (server internet), jadi Anda tidak perlu menginstal perangkat lunak apa pun di komputer Anda. Disini disediakan
            pilihan <b><i>Language </i></b>: <b>Sage</b> atau <b>Python</b> silahkan anda bisa memilih bekerja dengan 
            SageMath atau Python.
            </li>
            <li>
            <strong>ğŸ’¾ Simpan Semua</strong>: Menyimpan seluruh sesi kerja Anda (semua blok dan isinya) ke sebuah 
            file di komputer Anda (.json). Ini berguna jika Anda ingin memindahkan pekerjaan Anda ke komputer lain 
            atau membuat cadangan.
            </li>
            <li>
            <strong>ğŸ“‚ Impor File</strong>: Memuat sesi kerja yang sebelumnya Anda simpan dari file .json.
            </li>
            <li>
            <strong>ğŸ§¹ Bersihkan Data</strong>: Menghapus semua data sesi yang tersimpan di browser Anda. 
            Gunakan ini jika Anda ingin memulai dari awal atau menghapus pekerjaan lama.
            </li>
            </ul>
        </details>
    </section>
  
    <div class="horizontal-menu">
        <button class="btn" onclick="addTextBlock(this)">â• Teks LaTeX</button>
        <button class="btn" onclick="addMathliveBlock(this)">â• MathLive</button>
        <button class="btn" onclick="addSageCell(this)">â• SageMath</button>
        <button class="btn save-all-btn" id="saveBtn3">ğŸ’¾ Simpan Semua</button>
        <button class="btn import-btn" data-target="importFile3">ğŸ“‚ Impor File</button>
        <input type="file" id="importFile3" accept=".json" style="display:none" />
        <button class="btn" onclick="localStorage.clear(); alert('Data lokal dibersihkan!')">ğŸ§¹ Bersihkan Data</button>
    </div>
</div>
<hr>

<div class="container">
    <h2><b>4. Mengenal Berbagai Jenis Blok</b></h2>
    <section>
        <details>
            <summary class="judul-kolaborasi">
                âœ¨ <b>Membuat Blok Baru</b> 
            </summary>
            <p>Setiap blok memiliki fungsi unik untuk pengalaman matematika Anda:</p>
            <h3>4.1. Blok Teks \(\LaTeX\)</h3>
            <p style="text-align: justify;">
            Blok ini adalah kanvas Anda untuk menulis dan mempresentasikan matematika secara formal. 
            Anda akan melihat dua mode utama:
            </p>
            <ul style="text-align: justify;">
            <li><strong>Mode Edit:</strong> Ini adalah area tempat Anda mengetik teks dan kode \(\LaTeX\). 
            Misalnya, Anda bisa mengetik <code>$\mathbf{A} = \begin{pmatrix} 1 & 2 \\ 3 & 4 \end{pmatrix}$</code> 
            untuk mendefinisikan sebuah matriks, atau <code>$V = \text{span}\left\{ \mathbf{v}_1, \mathbf{v}_2 \right\}$</code> 
            untuk menunjukkan ruang bentangan.</li>
            <li><strong>Mode Pratinjau:</strong> Setelah Anda mengetik, klik tombol "â†”ï¸ Lihat Pratinjau" untuk 
            melihat bagaimana notasi \(\LaTeX\) Anda dirender menjadi persamaan yang indah dan mudah dibaca 
            oleh MathJax, seperti di buku teks. Anda bisa beralih kembali ke mode edit dengan tombol yang sama ("â†”ï¸ Edit Teks").</li>
            <li><strong>Tombol Hapus (ğŸ—‘):</strong> Menghapus blok ini dari halaman.</li>
            </ul>
            <h3>4.2. Blok MathLive</h3>
            <p style="text-align: justify;">
            Blok ini dirancang untuk kemudahan dan kecepatan. Jika Anda tidak terbiasa dengan \(\LaTeX\), ini 
            adalah titik awal yang sempurna:
            </p>
            <ul style="text-align: justify;">
            <li>Anda dapat mengetikkan ekspresi matematika secara langsung, dan MathLive akan secara otomatis 
            memformatnya dengan benar. Contoh: Ketik <code>[1, 2; 3, 4]</code> dan MathLive akan mengubahnya 
            menjadi \(\begin{bmatrix} 1 & 2 \\ 3 & 4 \end{bmatrix}\), atau ketik <code>det(A)</code> untuk \(\det(A)\). 
            Anda juga bisa mengetik <code>x_1 + 2x_2 = 5</code> untuk sistem persamaan linier.</li>
            <li>Ini sangat intuitif dan memberikan umpan balik visual langsung saat Anda membangun persamaan.</li>
            <li><strong>Tombol Hapus (ğŸ—‘):</strong> Menghapus blok ini.</li>
            </ul>
            <h3>4.3. Blok SageMath</h3>
            <p style="text-align: justify;">
            Ini adalah pusat komputasi Anda. Di sini, Anda dapat menggunakan kekuatan pemrograman dan matematika:
            </p>
            <ul style="text-align: justify;">
            <li>
            Anda akan melihat area untuk mengetikkan kode. Misalnya, Anda bisa mengetik <code>%display latex</code> 
            (untuk menampilkan <i>output</i> dalam format \(\LaTeX\)), lalu kode berikut untuk mendefinisikan 
            matriks dan menghitung determinannya:
            <pre><code>A = Matrix([[1, 2], [3, 4]])
            print(A.det())</code></pre>
            Atau untuk mencari nilai <i>eigen</i> dari matriks:
            <pre><code>B = Matrix([[4, 1], [2, 3]])
            print(B.eigenvalues())</code></pre>
            </li>
            <li>
            Klik tombol <strong>"Jalankan"</strong> (yang disediakan oleh SageMath) untuk mengeksekusi 
            kode Anda dan melihat hasilnya di bawahnya.
            </li>
            <li>
            <strong>Tombol "ğŸ“š Dokumentasi SageMath":</strong> Tautan langsung ke dokumentasi resmi 
            SageMath untuk membantu Anda belajar lebih banyak tentang fungsi-fungsi Aljabar Linier yang 
            tersedia (misalnya, operasi matriks, vektor, ruang vektor, transformasi linier).
            </li>
            <li>
            <strong>Tombol "â• Blok Kode \(\LaTeX\) Baru":</strong> Tombol ini akan menambahkan blok 
            teks \(\LaTeX\) baru (dengan judul "Blok Kode \(\LaTeX\)") ke halaman Anda. Karena alasan 
            keamanan teknis (yang melibatkan bagaimana <i>browser</i> berinteraksi dengan layanan <i>cloud</i> 
            seperti SageMath), kode dari editor SageMath tidak dapat langsung disalin secara otomatis. 
            Oleh karena itu, setelah Anda membuat blok baru ini, silakan <b>sorot dan salin (Ctrl+C atau Cmd+C) 
            kode dari editor SageMath Anda, lalu tempel (Ctrl+V atau Cmd+V) di blok Kode LaTeX yang baru</b>. Ini adalah cara manual yang sangat efektif untuk memindahkan kode Anda ke blok LaTeX untuk dokumentasi atau presentasi.
            </li>
            <li><strong>Tombol Hapus (ğŸ—‘):</strong> Menghapus blok ini.</li>
            </ul>

            <p align="justify" class="highlight">
            Penggunaan SageMath ini adalah contoh nyata bagaimana Anda memanfaatkan <strong>cloud computing</strong>. 
            Perhitungan yang kompleks dilakukan di server jauh (di internet), bukan di komputer Anda, sehingga Anda bisa 
            menggunakan alat canggih ini tanpa perlu instalasi berat atau komputer berkemampuan tinggi. Cukup dengan 
            koneksi internet!
            </p>
        </details>
    </section>

    <div class="horizontal-menu">
        <button class="btn" onclick="addTextBlock(this)">â• Teks LaTeX</button>
        <button class="btn" onclick="addMathliveBlock(this)">â• MathLive</button>
        <button class="btn" onclick="addSageCell(this)">â• SageMath</button>
        <button class="btn save-all-btn" id="saveBtn4">ğŸ’¾ Simpan Semua</button>
        <button class="btn import-btn" data-target="importFile4">ğŸ“‚ Impor File</button>
        <input type="file" id="importFile4" accept=".json" style="display:none" />
        <button class="btn" onclick="localStorage.clear(); alert('Data lokal dibersihkan!')">ğŸ§¹ Bersihkan Data</button>
    </div>
</div>
<hr>


<div class="container">
<h2><b>5. Bagaimana Semua Ini Saling Terkait dalam Pembelajaran?</b></h2>
<section>
<details>
  <summary class="judul-kolaborasi">
      âœ¨ <b>Keterkaitan dalam Pembelajaran</b> 
    </summary>
            <h2></h2>
            <p align="justify">
              Laboratorium ini dirancang untuk mendukung cara belajar yang modern:
            </p>
            <ul align="justify">
                <li>
                  <strong>Belajar Formal (\(\LaTeX\)):</strong> Biasakan diri Anda dengan penulisan matematika standar.
                </li>
                <li>
                  <strong>Eksplorasi Cepat (MathLive):</strong> Coba berbagai rumus tanpa hambatan sintaks, fokus pada ide.
                </li>
                <li>
                  <strong>Komputasi dan Verifikasi (SageMath):</strong> Jalankan perhitungan kompleks, verifikasi 
                  jawaban Anda, atau lihat bagaimana fungsi berperilaku. Ini adalah jembatan ke dunia <strong>AI</strong> 
                  dan <strong>data science</strong>, di mana kemampuan untuk memprogram dan menganalisis secara komputasi 
                  sangatlah penting.
                </li>
                <li>
                  <strong>Fleksibilitas:</strong> Anda dapat menggabungkan blok-blok ini. Misalnya, Anda bisa menghitung 
                  sesuatu di SageMath, lalu menyalin kode atau hasilnya ke blok Teks \(\LaTeX\) untuk dokumentasi atau ke blok 
                  MathLive untuk memodifikasi persamaan secara visual.
                </li>
                <li>
                  <strong>Pembelajaran Berbasis Proyek:</strong> Anda bisa menggunakan editor ini untuk mengerjakan proyek 
                  matematika kecil, mendokumentasikan langkah-langkah, dan melakukan perhitungan, semuanya dalam satu 
                  lingkungan.
                </li>
            </ul>
            <p align="justify">
              Dengan alat ini, Anda tidak hanya belajar matematika, tetapi juga mengembangkan keterampilan komputasi 
              yang berharga untuk masa depan di era digital dan AI. Sehingga memahami matematika secara utuh "<b>teori, 
              aplikasi (real problem) dan komputasi menjadi satu kesatuan yang tak-terpisah</b>."
            </p>
</details>
</section>
   <div class="horizontal-menu">
        <button class="btn" onclick="addTextBlock(this)">â• Teks LaTeX</button>
        <button class="btn" onclick="addMathliveBlock(this)">â• MathLive</button>
        <button class="btn" onclick="addSageCell(this)">â• SageMath</button>
        <button class="btn save-all-btn" id="saveBtn5">ğŸ’¾ Simpan Semua</button>
        <button class="btn import-btn" data-target="importFile5">ğŸ“‚ Impor File</button>
        <input type="file" id="importFile5" accept=".json" style="display:none" />
        <button class="btn" onclick="localStorage.clear(); alert('Data lokal dibersihkan!')">ğŸ§¹ Bersihkan Data</button>
    </div>
</div>
<hr>



<div class="container">
<h2><b>6. Contoh-contoh Interaktif dalam SageMath Cell</b></h2>
<section>
<details>
<summary class="judul-kolaborasi">
âœ¨ <b>Beberapa Kalkulator dalam SageMath</b> 
</summary>
    <section>
    <h2></h2>
    <p align="justify">
    Contoh berikut adalah hasil dari kode dalam SageMath suatu kalkulator menghitung sistem persamaan linier. 
    Untuk mengeksekusi tekan tombol <button>Aktifkan</button>.Anda bisa mengubah isian 
    <code>Persamaan i</code>, dimana <code>i=1,2,3</code> sesuai yang anda inginkan. Tekan 
    tombol Update untuk menampilkan hasil. 
    </p>
        <div id="LinearSystemSolver">
    <script type="text/x-sage">
# Definisikan variabel
# Definisikan variabel
x, y, z = var('x, y, z')

@interact
def solve_linear_system(
            # Input untuk persamaan pertama
            eq1_str = input_box("2*x + y == 5", label="Persamaan 1"),
            # Input untuk persamaan kedua
            eq2_str = input_box("x - 3*y == -1", label="Persamaan 2"),
            # Input untuk persamaan ketiga (dengan nilai default)
            eq3_str = input_box("x + y + z == 6", label="Persamaan 3"),
            auto_update=False
        ):
            equations = []
            
            try:
                # --- Proses Persamaan 1 (Wajib) ---
                eq1_cleaned = str(eq1_str).strip()
                if not eq1_cleaned:
                    raise ValueError("Persamaan 1 tidak boleh kosong.")
                try:
                    eq1 = sage_eval(eq1_cleaned, locals={'x': x, 'y': y, 'z': z})
                    equations.append(eq1)
                except SyntaxError:
                    raise ValueError("Format Persamaan 1 tidak valid. Pastikan menggunakan format seperti '2*x + y == 5'.")
                except Exception as e:
                    raise ValueError(f"Kesalahan pada Persamaan 1: {e}")

                # --- Proses Persamaan 2 (Wajib) ---
                eq2_cleaned = str(eq2_str).strip()
                if not eq2_cleaned:
                    raise ValueError("Persamaan 2 tidak boleh kosong.")
                try:
                    eq2 = sage_eval(eq2_cleaned, locals={'x': x, 'y': y, 'z': z})
                    equations.append(eq2)
                except SyntaxError:
                    raise ValueError("Format Persamaan 2 tidak valid. Pastikan menggunakan format seperti '2*x + y == 5'.")
                except Exception as e:
                    raise ValueError(f"Kesalahan pada Persamaan 2: {e}")

                # --- Proses Persamaan 3 (Sekarang memiliki default, tapi masih bisa dihapus) ---
                eq3_cleaned = str(eq3_str).strip()
                # Jika pengguna menghapus isinya (sehingga menjadi kosong), kita tidak menambahkannya
                if eq3_cleaned: 
                    try:
                        eq3 = sage_eval(eq3_cleaned, locals={'x': x, 'y': y, 'z': z})
                        equations.append(eq3)
                    except SyntaxError:
                        raise ValueError("Format Persamaan 3 tidak valid. Pastikan menggunakan format seperti 'x + y + z == 6'.")
                    except Exception as e:
                        raise ValueError(f"Kesalahan pada Persamaan 3: {e}")
                
                if len(equations) < 2:
                    pretty_print(html("<p style='color:red;'>Mohon masukkan setidaknya dua persamaan yang valid.</p>"))
                    return

                # Dapatkan daftar variabel yang relevan dari semua persamaan yang diinput
                relevant_vars = set()
                for eq in equations:
                    relevant_vars.update(eq.variables())
                relevant_vars = sorted(list(relevant_vars)) # Urutkan untuk konsistensi

                if not relevant_vars:
                    pretty_print(html("<p style='color:red;'>Persamaan yang dimasukkan tidak mengandung variabel yang dapat diselesaikan (x, y, z).</p>"))
                    return

                # Selesaikan sistem persamaan
                solutions = solve(equations, *relevant_vars)

                if solutions:
                    pretty_print(html("<h2>Solusi Sistem Persamaan Linear:</h2>"))
                    if isinstance(solutions, list) and all(isinstance(s, dict) for s in solutions):
                        for sol in solutions:
                            sol_latex = ", ".join([f"{latex(k)} = {latex(v)}" for k, v in sol.items()])
                            pretty_print(html(f"$$ \\begin{{cases}} {sol_latex} \\end{{cases}} $$"))
                    elif isinstance(solutions, list) and all(isinstance(s, sage.symbolic.expression.Expression) for s in solutions):
                        pretty_print(html("$$" + latex(Set(solutions[0])) + "$$"))
                    else:
                        pretty_print(html("$$" + latex(Set(solutions[0])) + "$$")) # Fallback
                else:
                    pretty_print(html("<p>Sistem tidak memiliki solusi tunggal, mungkin tidak konsisten (tidak ada solusi) atau bergantung (solusi tak hingga).</p>"))

            except ValueError as e:
                pretty_print(html(f"<p style='color:red;'>Terjadi kesalahan input: {e}</p>"))
            except Exception as e:
                pretty_print(html(f"<p style='color:red;'>Terjadi kesalahan tak terduga: {e}<br>Mohon periksa kembali input Anda atau hubungi dukungan.</p>"))
    </script>
</div>
<hr>
    <p align="justify">
     Selanjutnya kita berikan contoh membuat matriks random ukuran \(5\times 5\) yang elemen-elemennya di 
     \(\mathbb{Z}\), dan dihitung \(\det(A)\) serta polinomial kharakteristik dari \(A\).
    </p>

<script src="https://sagecell.sagemath.org/static/embedded_sagecell.js"></script>
    <script>
    // Make the div with id 'mycell' a Sage cell
    sagecell.makeSagecell({inputLocation:  '#matriks',
                           template:       sagecell.templates.minimal,
                           evalButtonText: 'Jalankan'});
    // Make *any* div with class 'compute' a Sage cell
    sagecell.makeSagecell({inputLocation: 'div.compute',
                           evalButtonText: 'Evaluate'});
    </script>

<div id="matriks">
<script type="text/x-sage">
A = random_matrix(ZZ, 5)
d = A.det()
p = factor(A.charpoly("lambda"))

display(html(r"$A = %s"%(latex(A))))
display(html(r"$p(\lambda) = %s"%(latex(p))))
display(html(r"$\det(A) = %s"%(latex(d))))
</script>
</div>
<hr>
<p align="justify">
Berikut kita berikan kalkulator menyeleslesaikan \(Ax=b\) menggunakan: <b>Bentuk Eselon Baris Tereduksi</b>.
Kita bahas <b>langkah-langkah perubahan baris</b> yang terjadi di balik metode <code>.rref()</code> 
di SageMath.
</p>
<p align="justify">
Proses untuk mengubah suatu matriks menjadi <b>bentuk eselon baris tereduksi
(<i>Reduced Row Echelon Form</i> - RREF)</b> disebut <b>eliminasi Gauss-Jordan</b>. 
Ini melibatkan serangkaian <b>Operasi Baris Elementer (OBE)</b>. 
Ada tiga jenis OBE yang diizinkan:
</p>
<ol align="justify">
<li>  <b>Menukar Dua Baris (Row Swap)</b></li>
<li>  <b>Mengalikan Sebuah Baris dengan Skalar Bukan Nol (Scalar Multiplication)</b></li>
<li>  <b>Menambahkan Kelipatan Satu Baris ke Baris Lain (Row Addition)</b></li>
</ol>
<p align="justify">
Tujuannya adalah untuk mendapatkan matriks dalam bentuk RREF, yang memiliki properti berikut:
</p>
<ul align="justify">
<li> Semua baris nol (jika ada) berada di bagian bawah matriks.</li>
<li> "Angka 1 utama" (leading 1 atau pivot) dari setiap baris tak-nol berada di sebelah kanan angka 1 utama baris di atasnya.</li>
<li> Setiap kolom yang mengandung angka 1 utama memiliki nol di semua posisi lain (di atas dan di bawah angka 1 utama tersebut).</li>
</ul>
<p align="justify">
Mari kita lihat langkah-langkah umumnya:
</p>
<hr>

<h3> Langkah-langkah Eliminasi Gauss-Jordan (OBE)</h3>
<p align="justify">
Eliminasi Gauss-Jordan dibagi menjadi dua fase utama:
</p>
<h4> Fase 1: Eliminasi Maju (Membentuk Eselon Baris - Row Echelon Form)</h4>
<p align="justify">
Tujuan fase ini adalah menciptakan angka 1 utama dan nol di bawahnya, bergerak dari kolom kiri ke kanan.
</p>
<ol align="justify">
<li> <b>Pilih Pivot untuk Kolom Pertama (yang bukan kolom konstanta):</b>
    <ul align="justify">
    <li> Cari baris pertama yang tidak nol. Jika elemen di posisi \((1,1)\) (baris 1, kolom 1) adalah nol, 
    cari baris lain di bawahnya yang memiliki elemen tak-nol di kolom yang sama.
    </li>
    <li> <b>Jika ditemukan</b>: Tukar baris tersebut dengan baris pertama. Ini disebut <b>operasi penukaran baris</b>.
        <ul align="justify">
        <li> <b>Contoh (Tukar \(B_1\) dan \(B_2\))</b>:
            $$
            \begin{pmatrix}
            0 & 1 & 2 & | & 3 \\
            1 & 2 & 3 & | & 4 \\
            4 & 5 & 6 & | & 7
            \end{pmatrix}
            \xrightarrow{B_1 \leftrightarrow B_2}
            \begin{pmatrix}
            1 & 2 & 3 & | & 4 \\
            0 & 1 & 2 & | & 3 \\
            4 & 5 & 6 & | & 7
            \end{pmatrix}
            $$
        </li>
        </ul>
    </li>
    </ul>
</li>
<li> <b>Normalisasi Pivot Pertama menjadi 1:</b>
    <ul align="justify">
    <li> Jika elemen pivot (yang baru saja Anda pindahkan ke posisi \((1,1)\)) bukan 1, 
        <b>kalikan seluruh baris tersebut</b> dengan kebalikan dari nilai pivot agar elemen pivot menjadi 1. 
        Ini adalah <b>operasi perkalian skalar baris</b>.
        <ul align="justify">
        <li> <b>Contoh (Kalikan \(B_1\) dengan \(\frac{1}{2}\))</b>:
            $$
            \begin{pmatrix}
            2 & 4 & 6 & | & 8 \\
            0 & 1 & 2 & | & 3 \\
            4 & 5 & 6 & | & 7
            \end{pmatrix}
            \xrightarrow{\frac{1}{2}B_1 \to B_1}
            \begin{pmatrix}
            1 & 2 & 3 & | & 4 \\
            0 & 1 & 2 & | & 3 \\
            4 & 5 & 6 & | & 7
            \end{pmatrix}
            $$
        </li>
        </ul>
    </ul>
    </ul>
</li>
<li> <b>Eliminasi Elemen di Bawah Pivot (Menjadi Nol):</b>
    <ul align="justify">
    <li> Gunakan baris yang memiliki pivot (sekarang 1) untuk membuat semua elemen di bawah pivot tersebut menjadi nol.</li>
    <li>Lakukan <b>operasi penambahan baris</b>: Tambahkan kelipatan yang sesuai dari baris pivot ke baris-baris di bawahnya.</li>
        <ul align="justify">
        <li><b>Contoh (\(B_3 - 4B_1 \to B_3\))</b>:
            $$
            \begin{pmatrix}
            1 & 2 & 3 & | & 4 \\
            0 & 1 & 2 & | & 3 \\
            4 & 5 & 6 & | & 7
            \end{pmatrix}
            \xrightarrow{B_3 - 4B_1 \to B_3}
            \begin{pmatrix}
            1 & 2 & 3 & | & 4 \\
            0 & 1 & 2 & | & 3 \\
            0 & -3 & -6 & | & -9
            \end{pmatrix}
            $$
        </li>
        </ul>
    </ul>
    </ul>
</li>
<li> <b>Ulangi untuk Kolom Berikutnya:</b>
    <ul align="justify">
    <li>Pindah ke baris kedua, lalu cari pivot di kolom berikutnya (kolom 2). Ulangi langkah 1-3 untuk kolom ini, 
    pastikan Anda hanya menggunakan baris di bawah baris saat ini.</li>
    <li>Terus lakukan ini sampai semua kolom matriks koefisien (kecuali kolom konstanta) memiliki pivot 1 
    dengan nol di bawahnya.
    </li>
    </ul>
</li>
</ol>
<p align="justify">
Setelah fase 1 selesai, matriks Anda akan berada dalam <b>Bentuk Eselon Baris (<i>Row Echelon Form</i> - REF)</b>.
</p>
<hr>

<h4>Fase 2: Eliminasi Mundur (Membentuk Eselon Baris Tereduksi - <i>Reduced Row Echelon Form</i>)</h4>
<p align="justify">
Tujuan fase ini adalah membuat nol di atas setiap angka 1 utama, bergerak dari kanan ke kiri.
</p>
<ol align="justify">
<li> <b>Pilih Pivot Terakhir:</b>
    <ul align="justify">
    <li> Mulai dari angka 1 utama di baris terakhir (paling bawah) yang tidak nol.</li>
    </ul>
</li>
<li> <b>Eliminasi Elemen di Atas Pivot (Menjadi Nol):</b>
    <ul align="justify">
    <li> Gunakan baris yang memiliki pivot ini untuk membuat semua elemen di atas pivot tersebut menjadi nol.</li>
    <li> Lakukan <b>operasi penambahan baris</b>: Tambahkan kelipatan yang sesuai dari baris pivot ke baris-baris di atasnya.
        <ul align="justify">
        <li> <b>Contoh (jika pivot di (2,2) adalah 1, dan kita ingin nol di (1,2))</b>:
            $$
            \begin{pmatrix}
            1 & 2 & 3 & | & 4 \\
            0 & 1 & 2 & | & 3 \\
            0 & 0 & 0 & | & 0
            \end{pmatrix}
            \xrightarrow{R_1 - 2R_2 \to R_1}
            \begin{pmatrix}
            1 & 0 & -1 & | & -2 \\
            0 & 1 & 2 & | & 3 \\
            0 & 0 & 0 & | & 0
            \end{pmatrix}
            $$
        </li>
        </ul>
    </ul>
    </ul>
</li>
<li> <b>Ulangi untuk Pivot Sebelumnya:</b>
    <ul align="justify">
    <li> Pindah ke angka 1 utama di baris di atasnya (bergerak ke kiri dan ke atas). Ulangi langkah 2 untuk pivot ini.</li>
    <li>Terus lakukan ini sampai semua kolom yang memiliki angka 1 utama memiliki nol di atas dan di bawah angka 1 utama
     tersebut.
     </li>
    </ul>
</li>
</ol>
<p align="justify">
Setelah fase 2 selesai, matriks Anda akan berada dalam <b>Bentuk Eselon Baris Tereduksi (RREF)</b>. 
Dari bentuk ini, solusi sistem persamaan linear dapat langsung dibaca, atau jika ada baris nol yang 
tidak konsisten (0 = tak-nol), berarti tidak ada solusi.
</p>
<p align="justify">
SageMath <code>.rref()</code> melakukan semua langkah ini secara internal, sehingga Anda tidak 
perlu mengkodekannya sendiri. Ini sangat efisien dan akurat!
</p>
<div id="nonlin">
<script type="text/x-sage">
# Definisikan variabel simbolik
x, y, z = var('x, y, z')

@interact
def solve_linear_system_rref(
            # Input untuk persamaan pertama
            eq1_str = input_box("2*x + y == 5", label="Persamaan 1"),
            # Input untuk persamaan kedua
            eq2_str = input_box("x - 3*y == -1", label="Persamaan 2"),
            # Input untuk persamaan ketiga (default kosong, bisa diisi untuk 3x3)
            eq3_str = input_box("x + y + z == 6", label="Persamaan 3 (Opsional)"),
            auto_update=False
        ):
            equations = []
            
            try:
                # --- Proses Persamaan 1 (Wajib) ---
                eq1_cleaned = str(eq1_str).strip()
                if not eq1_cleaned:
                    raise ValueError("Persamaan 1 tidak boleh kosong.")
                eq1 = sage_eval(eq1_cleaned, locals={'x': x, 'y': y, 'z': z})
                equations.append(eq1)

                # --- Proses Persamaan 2 (Wajib) ---
                eq2_cleaned = str(eq2_str).strip()
                if not eq2_cleaned:
                    raise ValueError("Persamaan 2 tidak boleh kosong.")
                eq2 = sage_eval(eq2_cleaned, locals={'x': x, 'y': y, 'z': z})
                equations.append(eq2)

                # --- Proses Persamaan 3 (Opsional) ---
                eq3_cleaned = str(eq3_str).strip()
                if eq3_cleaned: 
                    eq3 = sage_eval(eq3_cleaned, locals={'x': x, 'y': y, 'z': z})
                    equations.append(eq3)
                
                if len(equations) < 2:
                    pretty_print(html("<p style='color:red;'>Mohon masukkan setidaknya dua persamaan yang valid.</p>"))
                    return

                # Dapatkan daftar variabel yang relevan dari semua persamaan yang diinput
                relevant_vars_set = set()
                for eq in equations:
                    relevant_vars_set.update(eq.variables())
                all_vars = sorted(list(relevant_vars_set), key=str)

                if not all_vars:
                    pretty_print(html("<p style='color:red;'>Persamaan yang dimasukkan tidak mengandung variabel yang dapat diselesaikan (x, y, z).</p>"))
                    return

                # Bangun matriks koefisien A dan vektor konstanta b
                A_rows = []
                b_vector = []
                for eq in equations:
                    # Ubah persamaan menjadi bentuk canonical: expr == 0
                    expr = eq.lhs() - eq.rhs()
                    
                    row = []
                    for var_sym in all_vars:
                        coeff = expr.coefficient(var_sym)
                        row.append(coeff)
                    
                    constant_b = -expr.subs({v: 0 for v in all_vars}) 
                    b_vector.append(constant_b)
                    A_rows.append(row)

                A_sage = Matrix(QQ, A_rows) # Matriks Sage untuk koefisien
                b_sage = vector(QQ, b_vector) # Vektor Sage untuk konstanta

                pretty_print(html("<h2>Matriks Augmented A|b:</h2>"))
                augmented_matrix_sage = A_sage.augment(b_sage)
                pretty_print(augmented_matrix_sage)
                pretty_print(html("$$" + latex(augmented_matrix_sage) + "$$"))

                # --- Bagian yang Disederhanakan: Menggunakan .rref() ---
                pretty_print(html("<h2>Bentuk Eselon Baris Tereduksi (RREF):</h2>"))
                rref_matrix = augmented_matrix_sage.rref()
                pretty_print(rref_matrix)
                pretty_print(html("$$" + latex(rref_matrix) + "$$"))

                # Ekstrak solusi dari RREF
                solutions_dict = {}
                is_consistent = True
                
                num_rows_rref = rref_matrix.nrows()
                num_cols_rref = rref_matrix.ncols()

                for i in range(num_rows_rref):
                    # Cek apakah ada baris kontradiksi (0 0 ... 0 | tak-nol)
                    is_zero_row_lhs = all(rref_matrix[i, col] == 0 for col in range(num_cols_rref - 1))
                    if is_zero_row_lhs and rref_matrix[i, num_cols_rref - 1] != 0:
                        is_consistent = False
                        break # Sistem tidak konsisten

                    # Jika baris bukan baris nol sepenuhnya dan bukan kontradiksi
                    if not is_zero_row_lhs:
                        # Cari variabel dasar (pivot)
                        pivot_col = -1
                        for col_idx in range(num_cols_rref - 1):
                            if rref_matrix[i, col_idx] == 1 and all(rref_matrix[i, k] == 0 for k in range(col_idx)):
                                pivot_col = col_idx
                                break
                        
                        if pivot_col != -1:
                            var_name = all_vars[pivot_col]
                            value = rref_matrix[i, num_cols_rref - 1]
                            solutions_dict[var_name] = value

                if not is_consistent:
                    pretty_print(html("<p style='color:red;'>Sistem tidak konsisten (tidak ada solusi).</p>"))
                elif len(solutions_dict) < len(all_vars):
                    pretty_print(html("<p>Sistem memiliki solusi tak hingga. Variabel bebas:</p>"))
                    free_vars = [v for v in all_vars if v not in solutions_dict]
                    for fv in free_vars:
                        pretty_print(html(f'$${latex(fv)} = {latex(fv)} \\text{{ (variabel bebas)}}$$'))
                    
                    pretty_print(html("<p>Solusi variabel dasar dalam bentuk variabel bebas:</p>"))
                    for var_name, value in solutions_dict.items():
                        pretty_print(html(f"$${latex(var_name)} = {latex(value)}$$"))

                else:
                    pretty_print(html("<h2>Solusi Akhir:</h2>"))
                    for var_name in all_vars:
                        if var_name in solutions_dict:
                            pretty_print(html(f"$${latex(var_name)} = {latex(solutions_dict[var_name])}$$"))
                        else:
                            # Ini seharusnya tidak terjadi jika ada solusi tunggal dan jumlah variabel = jumlah persamaan
                            pretty_print(html(f"<p style='color:orange;'>Peringatan: Variabel {latex(var_name)} tidak ditemukan dalam solusi eksplisit. Ini bisa menunjukkan masalah.</p>"))

            except (SyntaxError, ValueError) as e:
                pretty_print(html(f"<p style='color:red;'>Terjadi kesalahan input: {e}. Pastikan format persamaan sudah benar (misal: '2*x + y == 5').</p>"))
            except Exception as e:
                pretty_print(html(f"<p style='color:red;'>Terjadi kesalahan tak terduga: {e}<br>Mohon periksa kembali input Anda atau hubungi dukungan.</p>"))
</script>
</div>
<hr>

<h2>ğŸ“ Eliminasi Gauss</h2>
<details>
  <summary class="judul-kolaborasi">
    âœ¨ <b>Program Interaktif Eliminasi Gauss</b> 
    </summary>
<p align="justify">
Program interaktif berikut adalah alat bantu yang dirancang untuk mempermudah pemahaman kita tentang 
<b>Eliminasi Gauss</b> dalam penyelesaian sistem persamaan linear. Kita dapat memasukkan matriks 
koefisien ($A$) dan vektor konstanta ($b$) dari sistem yang ingin kita selesaikan. Uniknya, program 
ini menawarkan opsi untuk menampilkan setiap langkah eliminasi secara detail, dan yang terpenting, 
semua perhitungan dilakukan menggunakan <b>pecahan (bilangan rasional)</b>. Pendekatan ini menjamin 
keakuratan hasil dengan menghindari kesalahan pembulatan yang sering terjadi pada bilangan desimal.
</p>

<h3> Fungsi Penampil Matriks Diperbesar </h3>
<p align="justify">
Ada sebuah fungsi inti dalam program yang bertanggung jawab untuk menampilkan <b>matriks diperbesar ($[A|b]$)</b>. 
Fungsi ini mengambil matriks koefisien ($A$) dan vektor konstanta ($b$) sebagai input. Kemudian, ia akan memformat 
matriks tersebut ke dalam representasi $\LaTeX$ yang standar dan mudah dibaca, lengkap dengan garis vertikal yang 
memisahkan matriks $A$ dari vektor $b$. Tampilan ini sangat membantu untuk memvisualisasikan sistem persamaan 
linear dalam bentuk matriks.
</p>

<h3> Fungsi Interaktif Utama: Penyelesaian Sistem Linear</h3>
<p align="justify">
Bagian utama program ini merupakan antarmuka interaktif yang mengelola seluruh proses Eliminasi Gauss.
</p>
<p align="justify">
Pengguna berinteraksi dengan program melalui beberapa input:
</p>
<ul align="justify">
<li> <b>Matriks A:</b> Input teks untuk matriks koefisien ($A$), dengan contoh format seperti <code>[[2,1,1],[2,3,1],[1,-1,2]]</code>.</li>
<li> <b>Vektor b:</b> Input teks untuk vektor konstanta ($b$), dengan contoh format seperti <code>[2,5,3]</code>.</li>
<li> <b>Tampilkan Langkah Eliminasi?:</b> Sebuah kotak centang yang memungkinkan pengguna untuk melihat setiap tahapan 
    Eliminasi Gauss secara bertahap.</li>
</ul>
<p align="justify">
Sebelum memulai perhitungan, program akan <b>memvalidasi input</b> kita. Matriks $A$ dan vektor $b$ yang dimasukkan 
akan dikonversi menjadi objek matriks dan vektor dalam <b>lapangan bilangan rasional ($\mathbb{Q}$)</b>. Penggunaan 
$\mathbb{Q}$ ini krusial karena memastikan bahwa semua perhitungan, bahkan pembagian sekalipun, akan menghasilkan 
pecahan yang presisi, bukan aproksimasi desimal yang bisa menyebabkan galat pembulatan. Jika format input tidak valid, 
program akan menampilkan pesan kesalahan.
</p>
<p align="justify">
Setelah input berhasil divalidasi, program akan menampilkan kembali <b>sistem persamaan linear awal</b> dalam 
bentuk aljabar yang familiar, misalnya $2x_1 + x_2 + x_3 = 2$. Selanjutnya, <b>matriks diperbesar awal $[A|b]$</b> 
juga akan ditampilkan, memberikan representasi visual dari sistem yang akan dipecahkan.
</p>

<h4> Langkah-langkah Eliminasi Gauss (Opsional)</h4>
<p align="justify">
Jika kita memilih untuk menampilkan langkah-langkah eliminasi, program akan memulai proses <b>Eliminasi Maju</b> 
untuk mengubah matriks diperbesar menjadi <b>bentuk eselon baris</b>. Proses ini melibatkan serangkaian <b> 
baris elementer</b>:
</p>
<ol align="justify">
<li> <b>Pemilihan Pivot:</b> Program berfokus pada elemen diagonal utama sebagai "pivot" potensial.</li>
<li> <b>Penanganan Pivot Nol:</b> Jika elemen pivot saat ini bernilai nol, program akan mencari baris di 
    bawahnya yang memiliki entri tak-nol pada kolom yang sama. Jika ditemukan, kedua baris tersebut akan 
    <b>ditukar posisinya</b>. Program akan menampilkan pesan yang menjelaskan pertukaran ini dan menampilkan 
    kembali matriks yang telah diperbarui.
</li>
<li> <b>Eliminasi Elemen di Bawah Pivot:</b> Untuk setiap baris di bawah baris pivot saat ini, program akan 
    menghitung faktor (<code>f</code>) yang diperlukan. Faktor ini adalah nilai yang, ketika dikalikan dengan baris pivot 
    dan ditambahkan ke baris target, akan membuat elemen di bawah pivot menjadi nol. Operasi baris elementer ini, 
    yaitu <b>menambahkan kelipatan satu baris ke baris lain</b>, akan secara sistematis menciptakan nol di bawah 
    setiap pivot. Setelah setiap operasi, program akan menampilkan pesan yang menjelaskan operasi baris yang baru 
    saja dilakukan dan menunjukkan matriks diperbesar yang diperbarui.
</li>
</ol>
<p align="justify">
Setelah Eliminasi Maju selesai, program akan menampilkan <b>matriks diperbesar akhir</b> yang sudah dalam bentuk 
eselon baris atau mendekati bentuk eselon baris.
</p>

<h4>Analisis Solusi</h4>
<p align="justify">
Bagian terakhir program adalah <b>analisis solusi</b> dari sistem persamaan linear yang telah direduksi. 
Program akan mengekstrak matriks koefisien ($A_{red}$) dan vektor konstanta ($b_{red}$) dari matriks 
diperbesar yang telah dimodifikasi.
</p>
<p align="justify">
Kemudian, program akan mencoba menyelesaikan sistem persamaan linear yang baru ini.
</p>
<ul align="justify">
<li> Jika <b>solusi tunggal</b> ditemukan, program akan menampilkannya dalam format kamus, misalnya $\{x_1: 1, x_2: 0, x_3: 1\}$.</li>
<li>Jika sistem <b>tidak memiliki solusi tunggal</b> (misalnya, sistem tak tentu dengan banyak solusi atau sistem 
  inkonsisten tanpa solusi), program akan menampilkan pesan yang relevan seperti "Tidak ada solusi tunggal. 
  Sistem mungkin tak tentu atau tidak konsisten." Ini terjadi jika ada baris yang mengarah pada kontradiksi 
  (contohnya, $0 = 1$) atau jika ada variabel bebas.
</li>
</ul>
<p align="justify">
Program ini secara keseluruhan memberikan representasi visual dan langkah-demi-langkah yang jelas tentang bagaimana 
Eliminasi Gauss diterapkan untuk menemukan solusi sistem persamaan linear, dengan penekanan pada akurasi komputasi 
menggunakan bilangan rasional. Klik tombol <button>aktifkan</button> untuk menjalankan program.
</p> 
<div id="lucu3d">
<script type="text/x-sage">
# Fungsi menampilkan matriks diperbesar dalam blok [A | b]
def tampilkan_matriks_perbesar(A, b):
    nrows = A.nrows()
    ncols = A.ncols()
    latex_str = r'$$ \left[ \begin{array}{%s|c} ' % ('r'*ncols)

    for i in range(nrows):
        baris_A = ' & '.join(f'{A[i,j]}' for j in range(ncols))
        latex_str += f'{baris_A} & {b[i]} \\\\ '

    latex_str += r'\end{array} \right] $$'
    display(html(latex_str))

# Interaktif Eliminasi Gauss dengan format blok [A | b] dan aman pecahan
@interact
def SistemLinear(M_A = input_box(default='[(2,1,1),(2,3,1),(1,-1,2)]', label='Matriks A', type=str),
                 M_b = input_box(default='[2,5,3]', label='Vektor b', type=str),
                 tampilkan_langkah = checkbox(False, label='Tampilkan Langkah Eliminasi?')):

    try:
        A = matrix(QQ, eval(M_A))  # Langsung bidang pecahan
        b = vector(QQ, eval(M_b))
    except:
        display(html('<span style="color:red"> Format input tidak valid. Contoh matriks: [[1,2],[3,4]] dan vektor: [5,6]</span>'))
        return

    nvars = A.ncols()
    neqs = A.nrows()
    variables = var(','.join(f'x{i+1}' for i in range(nvars)))

    display(html('<h3><b>Sistem Persamaan Linear:</b></h3>'))
    for row, val in zip(A, b):
        show(sum(c*v for c,v in zip(row, variables)) == val)

    display(html('<h3><b>Matriks Diperbesar [A | b]:</b></h3>'))
    tampilkan_matriks_perbesar(A, b)

    if tampilkan_langkah:
        display(html('<h3><b>Langkah-Langkah Eliminasi Gauss:</b></h3>'))
        M_red = A.augment(b)  # Matriks sudah di bidang QQ

        for i in range(min(neqs, nvars)):
            # Tukar baris jika pivot 0
            if M_red[i,i] == 0:
                for k in range(i+1, neqs):
                    if M_red[k,i] != 0:
                        M_red.swap_rows(i, k)
                        display(html(f'Tukar baris {i+1} dengan baris {k+1}'))
                        tampilkan_matriks_perbesar(M_red[:, :-1], M_red.column(-1))
                        break

            # Eliminasi bawah
            for j in range(i+1, neqs):
                if M_red[j,i] != 0:
                    f = -M_red[j,i]/M_red[i,i]
                    M_red.add_multiple_of_row(j, i, f)
                    display(html(f'Baris {j+1} + ({f}) Ã— baris {i+1}'))
                    tampilkan_matriks_perbesar(M_red[:, :-1], M_red.column(-1))

        display(html('<h3><b>Matriks Setelah Eliminasi [A | b]:</b></h3>'))
        tampilkan_matriks_perbesar(M_red[:, :-1], M_red.column(-1))

        # Analisis Solusi
        A_red = M_red[:, :-1]
        b_red = M_red.column(-1)
        try:
            persamaan = [sum(c*v for c,v in zip(row, variables)) == val for row, val in zip(A_red, b_red)]
            sol = solve(persamaan, variables, solution_dict=True)

            if sol:
                display(html('<h3><b>Solusi:</b></h3>'))
                show(sol[0])
            else:
                display(html('<span style="color:red">Tidak ada solusi tunggal. Sistem mungkin tak tentu atau tidak konsisten.</span>'))
        except:
            display(html('<span style="color:red">Gagal menyelesaikan sistem, periksa format input atau struktur persamaan.</span>'))
</script>
</div>
</details>
<hr>

<h2>ğŸ“ Eliminasi Gauss-Jordan</h2>
<details>
  <summary class="judul-kolaborasi">
      âœ¨ <b>Program Interaktif Eliminasi Gauss-Jordan</b> 
    </summary>
<p align="justify">
Program interaktif ini dirancang untuk memvisualisasikan dan menyelesaikan sistem persamaan linear (SPL) 
menggunakan metode <b>Eliminasi Gauss-Jordan</b>. Metode ini adalah ekstensi dari Eliminasi Gauss, yang tidak hanya 
mengubah matriks menjadi bentuk eselon baris, tetapi terus mereduksinya hingga mencapai 
<b>bentuk eselon baris tereduksi</b>. Keunggulan utamanya adalah bahwa solusi SPL dapat langsung 
dibaca dari matriks yang direduksi. Program ini secara khusus menggunakan <b>pecahan (rasional)</b> 
untuk semua perhitungan, menjamin presisi absolut dan menghindari kesalahan pembulatan desimal.
</p>

<h3> Fungsi <code>tampilkan_matriks_perbesar(A, b)</code></h3>
<p align="justify">
Fungsi ini berfungsi sebagai alat visualisasi inti. Tujuannya adalah untuk menyajikan matriks diperbesar 
($[A|b]$) dalam format $\LaTeX$ yang rapi dan mudah dimengerti, memfasilitasi pelacakan langkah-langkah eliminasi.
</p>
<ul align="justify">
<li> <b>Input:</b>
    <ul align="justify">
    <li> <code>A</code>: Matriks koefisien dari SPL.</li>
    <li><code>b</code>: Vektor konstanta dari SPL.</li>
   </ul>
</li>
<li> <b>Fungsi:</b> Fungsi ini menghitung dimensi matriks <code>A</code> (<code>nrows</code> dan <code>ncols</code>), kemudian 
    secara dinamis membangun <i>string</i> $\LaTeX$. Setiap baris matriks <code>A</code> digabungkan dengan elemen 
    terkait dari vektor <code>b</code>, dipisahkan oleh garis vertikal (<code>|</code>) seperti dalam notasi matriks 
    diperbesar standar. Hasil <i>string</i> $\LaTeX$ ini kemudian dirender sebagai <b>HTML</b> untuk tampilan yang jelas.
</li>
</ul>

<h3>Fungsi Interaktif <code>SistemLinear_GaussJordan</code></h3>
<p align="justify">
Ini adalah komponen utama program yang menyediakan antarmuka pengguna dan mengelola seluruh proses Eliminasi Gauss-Jordan.
</p>
<ul align="justify">
<li> <b>Input Interaktif:</b>
    <ul align="justify">
    <li> <code>M_A</code>: Kotak input untuk <b>Matriks A</b> (misalnya, <code>[[2,1,1],[2,3,1],[1,-1,2]]</code>).</li>
    <li><code>M_b</code>: Kotak input untuk <b>Vektor b</b> (misalnya, <code>[2,5,3]</code>).</li>
    <li><code>tampilkan_langkah</code>: Sebuah <i>checkbox</i> yang memungkinkan pengguna untuk menampilkan atau 
    menyembunyikan setiap langkah detail dari proses eliminasi.
    </li>
    </ul>
</li>
<li> <b>Validasi Input:</b>
    <ol align="justify">
    <li>Program mencoba mengonversi <i>string</i> input <code>M_A</code> dan <code>M_b</code> menjadi objek 
        <b>matriks</b> dan <b>vektor</b> yang sesuai. Penting untuk dicatat bahwa <b><code>QQ</code> 
        (bidang bilangan rasional)</b> digunakan sebagai domain untuk entri matriks/vektor. Ini memastikan bahwa 
        semua perhitungan dilakukan dengan pecahan, menjaga presisi dan menghindari masalah pembulatan yang 
        terkait dengan bilangan <i>floating-point</i>.
    </li>
    <li>Jika format input tidak valid, pesan kesalahan akan ditampilkan, dan eksekusi akan dihentikan.</li>
    </ol>
</li>
<li> <b>Inisialisasi Sistem:</b>
    <ol align="justify">
    <li> <code>nvars</code>: Menentukan jumlah variabel dalam sistem, yang setara dengan jumlah kolom di matriks <code>A</code>.</li>
    <li> <code>neqs</code>: Menentukan jumlah persamaan, yang setara dengan jumlah baris di matriks <code>A</code>.</li>
    <li> <code>variables</code>: Membuat variabel simbolik (misalnya, $x_1, x_2, x_3, \dots$) berdasarkan <code>nvars</code>.</li>
    </ol>
</li>
<li> <b>Tampilan Awal Sistem:</b>
    <ol align="justify">
    <li> Program menampilkan judul "Sistem Persamaan Linear:" diikuti oleh representasi setiap persamaan linear asli, 
        misalnya $2x_1 + x_2 + x_3 = 2$.</li>
    <li>  Kemudian, judul "Matriks Diperbesar [A | b]:" ditampilkan, dan fungsi <code>tampilkan_matriks_perbesar</code> 
        digunakan untuk menunjukkan representasi matriks awal dari SPL.</li>
    </ol>
</li>
<li> <b>Langkah-Langkah Eliminasi Gauss-Jordan (Opsional):</b>
    Bagian ini adalah inti dari algoritma dan hanya dijalankan jika <code>tampilkan_langkah</code> dicentang. 
    Matriks diperbesar awal, <code>M_red</code>, dibuat dengan menggabungkan <code>A</code> dan <code>b</code>.
    <ol align="justify">
    <li> <b>Iterasi Utama (Pivot dan Eliminasi):</b>
        <ul align="">
        <li>Program mengulang dari <code>i = 0</code> hingga <code>min(neqs, nvars) - 1</code>. Variabel <code>i</code> 
            mewakili baris dan kolom pivot saat ini.
        </li>
        <li><b>Penanganan Pivot Nol:</b> Jika elemen diagonal <code>M_red[i,i]</code> (pivot) adalah nol, program mencari baris di 
        bawahnya (<code>k</code> dari <code>i+1</code> hingga <code>neqs-1</code>) yang memiliki elemen tak-nol di kolom yang sama. Jika ditemukan, 
        baris tersebut ditukar dengan baris <code>i</code> (<code>M_red.swap_rows(i, k)</code>). Pesan yang sesuai dan tampilan matriks 
        yang diperbarui disediakan.
        </li>
        <li><b>Normalisasi Pivot:</b> Jika pivot <code>M_red[i,i]</code> bukan 1 dan bukan 0, baris <code>i</code> dikalikan dengan 
        kebalikan dari pivot (<code>1/M_red[i,i]</code>) menggunakan <code>M_red.rescale_row(i, faktor)</code>. Tujuannya adalah 
        untuk membuat elemen pivot menjadi 1, yang merupakan langkah kunci dalam Eliminasi Gauss-Jordan. 
        Pesan dan tampilan matriks yang diperbarui disediakan.
        </li>
        <li><b>Eliminasi Atas dan Bawah:</b> Untuk setiap baris <code>j</code> (kecuali baris pivot <code>i</code> itu sendiri) yang 
        memiliki elemen tak-nol di kolom pivot <code>i</code>:
            <ul align="">
            <li> Faktor <code>f</code> dihitung sebagai negasi dari elemen <code>M_red[j,i]</code>.</li>
            <li>Kelipatan baris pivot <code>i</code> ditambahkan ke baris <code>j</code> 
                (<code>M_red.add_multiple_of_row(j, i, f)</code>) untuk membuat elemen <code>M_red[j,i]</code> menjadi nol. 
                Ini adalah langkah yang membedakan Gauss-Jordan dari Eliminasi Gauss, karena Eliminasi 
                Gauss-Jordan menciptakan nol di atas <b>dan</b> di bawah pivot. Pesan dan tampilan matriks yang 
                diperbarui disediakan untuk setiap operasi ini.
            </li>
            </ul>
        </li>
        </ul>
    </li>
    <li> <b>Tampilan Matriks Eselon Baris Tereduksi:</b> Setelah semua langkah eliminasi selesai, matriks <code>M_red</code> 
        yang sekarang berada dalam bentuk eselon baris tereduksi ditampilkan.
    </li>
    </ol>
</li>
<li> <b>Analisis Solusi:</b>
    Setelah matriks direduksi, program menganalisis sifat solusinya. Matriks <code>A_red</code> dan vektor 
    <code>b_red</code> diekstrak dari <code>M_red</code>.
    <ol align="justify">
    <li> <b>Pengecekan Inkonsistensi:</b>
        <ul align="justify">
        <li>Program memeriksa setiap baris di <code>A_red</code>. Jika ada baris yang semua elemennya nol 
        (<code>all(A_red[i,j] == 0 for j in range(nvars))</code>) tetapi elemen yang sesuai di <code>b_red</code> tidak 
        nol (<code>b_red[i] != 0</code>), ini menunjukkan sebuah <b>kontradiksi</b> (misalnya, $0 = 5$). Dalam kasus ini, 
        sistem dinyatakan <b>tidak konsisten</b> dan tidak memiliki solusi.
       </li> 
       </ul>
    </li>
    <li> <b>Penentuan Tipe Solusi (Jika Konsisten):</b>
        <ul align="justify">
        <li><b>Rank Matriks:</b> <code>rank_A</code> dihitung dari <code>A_red</code>. Rank adalah jumlah baris tak-nol dalam 
        bentuk eselon baris tereduksi, yang juga merupakan jumlah variabel <b>dasar</b>.</li>
        <li><b>Solusi Tunggal:</b> Jika rank matriks (<code>rank_A</code>) sama dengan jumlah variabel (<code>total_var</code>), berarti 
        tidak ada variabel bebas, dan sistem memiliki <b>solusi tunggal</b>.</li>
        <li><b>Solusi Tak Hingga:</b> Jika rank matriks lebih kecil dari jumlah variabel (<code>rank_A < total_var</code>), 
        berarti ada variabel bebas (<code>total_var - rank_A</code>), dan sistem memiliki <b>tak hingga solusi</b>.</li>
        <li><b>Kasus Lain:</b> Jika kondisi di atas tidak terpenuhi, program menyatakan bahwa sistem 
        "tidak dapat diselesaikan," meskipun skenario ini jarang terjadi jika logika inkonsistensi sudah ditangani.</li>
        </ul>
    </li>
    <li> <b>Menampilkan Solusi:</b>
        <ul align="justify">
        <li>Sistem persamaan linear yang telah direduksi dibentuk kembali dari <code>A_red</code> dan <code>b_red</code>.</li>
        <li>Fungsi <code>solve()</code> digunakan untuk menemukan solusi untuk <code>variables</code>.</li>
        <li>Jika solusi ditemukan (<code>sol</code> tidak kosong), solusi pertama (<code>sol[0]</code>) akan ditampilkan. 
        Ini akan menunjukkan nilai eksplisit untuk variabel dalam kasus solusi tunggal, atau ekspresi 
        parametrik untuk variabel dalam kasus tak hingga solusi.</li>
        <li>Jika <code>solve()</code> tidak mengembalikan solusi (misalnya, karena struktur persamaan yang 
        rumit yang tidak dapat dipecahkan secara langsung oleh <code>solve</code>), pesan "Solusi dalam bentuk 
        parametrik dapat ditulis tergantung variabel bebas." akan ditampilkan, mendorong pengguna 
        untuk menafsirkannya sendiri dari bentuk eselon baris tereduksi.</li>
       </ul>
    </li>
    </ol>
</ul>

<h3> Konsep Matematika Utama</h3>
<ol align="justify">
<li> <b>Sistem Persamaan Linear (SPL):</b> Kumpulan persamaan yang melibatkan variabel yang sama, 
yang tujuannya adalah menemukan nilai-nilai variabel yang memenuhi semua persamaan secara simultan.
</li>
<li> <b>Matriks Diperbesar ($[A|b]$):</b> Sebuah representasi ringkas dari SPL, di mana matriks 
koefisien ($A$) digabungkan dengan vektor konstanta ($b$).
</li>
<li> <b>Eliminasi Gauss-Jordan:</b> Sebuah algoritma sistematis untuk menyelesaikan SPL dengan mengubah 
matriks diperbesar menjadi <b>bentuk eselon baris tereduksi (RREF)</b> melalui serangkaian <b>operasi baris elementer</b>.
</li>
<li> <b>Operasi Baris Elementer:</b> Tiga jenis operasi yang dapat dilakukan pada baris matriks tanpa mengubah 
himpunan solusi SPL:
    <ul align="justify">
    <li><b>Penukaran Baris:</b> Menukar posisi dua baris ($R_i \leftrightarrow R_j$). Digunakan untuk mendapatkan 
    elemen pivot tak-nol.</li>
    <li><b>Perkalian Baris dengan Skalar Tak-nol:</b>> Mengalikan semua elemen dalam satu baris dengan 
    konstanta tak-nol ($kR_i \to R_i$). Digunakan untuk menormalkan pivot menjadi 1.</li>
    <li><b>Penambahan Kelipatan Satu Baris ke Baris Lain:</b> Menambahkan kelipatan satu baris ke baris 
    lain ($R_j + kR_i \to R_j$). Digunakan untuk menciptakan nol di atas dan di bawah elemen pivot.</li>
    </ul>
</li>
<li> <b>Bentuk Eselon Baris Tereduksi (RREF):</b> Matriks memenuhi kondisi berikut:
    <ul align="justify">
    <li>Semua baris yang seluruhnya nol berada di bagian bawah matriks.</li>
    <li>Untuk setiap baris tak-nol, elemen tak-nol pertama (disebut <b>pivot</b> atau <b>leading 1</b>) adalah 1.</li>
    <li>Setiap pivot berada di kolom di sebelah kanan pivot dari baris di atasnya.</li>
    <li>Setiap kolom yang mengandung pivot memiliki nol di semua posisi lain (di atas dan di bawah pivot).</li>
    </ul>
</li>
<li> <b>Bidang Bilangan Rasional ($\mathbb{Q}$):</b> Penggunaan $\mathbb{Q}$ (diwakili oleh <code>QQ</code> dalam program) 
sangat penting untuk menjaga <b>presisi absolut</b> selama semua perhitungan. Ini memastikan bahwa pecahan ditangani 
dengan tepat dan tidak ada kesalahan pembulatan yang terjadi, yang seringkali menjadi masalah saat menggunakan 
representasi <i>floating-point</i>.
</li>
<li><b>Rank Matriks:</b> Jumlah baris tak-nol dalam bentuk eselon baris tereduksi dari suatu matriks. 
Ini juga merupakan jumlah variabel dasar (variabel yang sesuai dengan kolom pivot).
</li>
<li> <b>Jenis Solusi SPL:</b>
    <ul align="justify">
    <li> <b>Sistem Konsisten:</b> Memiliki setidaknya satu solusi.
        <ul align="">
        <li><b>Solusi tunggal:</b> Jika rank matriks koefisien sama dengan jumlah variabel.</li>
        <li><b>Solusi Tak Hingga:</b> Jika rank matriks koefisien kurang dari jumlah variabel 
        (mengindikasikan adanya variabel bebas).</li>
        </ul>
    </li>
    <li><b>Sistem Tidak Konsisten:</b> Tidak memiliki solusi. Ini terjadi ketika Eliminasi Gauss-Jordan 
    menghasilkan baris dalam bentuk eselon baris tereduksi yang setara dengan pernyataan kontradiktif, 
    seperti $0 = k$ di mana $k \neq 0$.</li>
    </ul>
</li>
</ol>
<p align="justify">
Program ini menyediakan lingkungan yang interaktif dan transparan untuk mempelajari dan menerapkan <b>Eliminasi 
Gauss-Jordan</b>, memungkinkan kita untuk secara visual mengikuti transformasi matriks dan memahami implikasi 
matematika dari setiap langkah dalam menemukan solusi <b>SPL</b>.
</p>

<div id="sikloida">
<script type="text/x-sage">
# Fungsi menampilkan matriks diperbesar blok [A | b]
def tampilkan_matriks_perbesar(A, b):
    nrows = A.nrows()
    ncols = A.ncols()
    latex_str = r'$$ \left[ \begin{array}{%s|c} ' % ('r'*ncols)
    for i in range(nrows):
        baris_A = ' & '.join(f'{A[i,j]}' for j in range(ncols))
        latex_str += f'{baris_A} & {b[i]} \\\\ '
    latex_str += r'\end{array} \right] $$'
    display(html(latex_str))


# Interaktif Eliminasi Gauss-Jordan lengkap dengan blok [A | b]
@interact
def SistemLinear_GaussJordan(M_A = input_box(default='[(2,1,1),(2,3,1),(1,-1,2)]', label='Matriks A', type=str),
                             M_b = input_box(default='[2,5,3]', label='Vektor b', type=str),
                             tampilkan_langkah = checkbox(False, label='Tampilkan Langkah Eliminasi Gauss-Jordan?')):

    try:
        A = matrix(QQ, eval(M_A))
        b = vector(QQ, eval(M_b))
    except:
        display(html('<span style="color:red">âŒ Format input tidak valid. Contoh: [[1,2],[3,4]] dan [5,6]</span>'))
        return

    nvars = A.ncols()
    neqs = A.nrows()
    variables = var(','.join(f'x{i+1}' for i in range(nvars)))

    display(html('<h3><b>Sistem Persamaan Linear:</b></h3>'))
    for row, val in zip(A, b):
        show(sum(c*v for c,v in zip(row, variables)) == val)

    display(html('<h3><b>Matriks Diperbesar [A | b]:</b></h3>'))
    tampilkan_matriks_perbesar(A, b)

    M_red = A.augment(b)

    if tampilkan_langkah:
        display(html('<h3><b>Langkah-Langkah Eliminasi Gauss-Jordan:</b></h3>'))

        for i in range(min(neqs, nvars)):
            # Tukar baris jika pivot 0
            if M_red[i,i] == 0:
                for k in range(i+1, neqs):
                    if M_red[k,i] != 0:
                        M_red.swap_rows(i, k)
                        display(html(f'Tukar baris {i+1} dengan baris {k+1}'))
                        tampilkan_matriks_perbesar(M_red[:, :-1], M_red.column(-1))
                        break

            # Normalisasi pivot
            if M_red[i,i] != 1 and M_red[i,i] != 0:
                faktor = 1/M_red[i,i]
                M_red.rescale_row(i, faktor)
                display(html(f'Baris {i+1} dikali {faktor}'))
                tampilkan_matriks_perbesar(M_red[:, :-1], M_red.column(-1))

            # Eliminasi atas & bawah
            for j in range(neqs):
                if j != i and M_red[j,i] != 0:
                    f = -M_red[j,i]
                    M_red.add_multiple_of_row(j, i, f)
                    display(html(f'Baris {j+1} + ({f}) Ã— baris {i+1}'))
                    tampilkan_matriks_perbesar(M_red[:, :-1], M_red.column(-1))

        display(html('<h3><b>Matriks Eselon Baris Tereduksi [A | b]:</b></h3>'))
        tampilkan_matriks_perbesar(M_red[:, :-1], M_red.column(-1))

    # Analisis Solusi
    A_red = M_red[:, :-1]
    b_red = M_red.column(-1)

    # Cek inkonsistensi
    tidak_konsisten = False
    for i in range(neqs):
        if all(A_red[i,j] == 0 for j in range(nvars)) and b_red[i] != 0:
            tidak_konsisten = True
            break

    if tidak_konsisten:
        display(html('<span style="color:red"><b>Sistem tidak konsisten, tidak ada solusi.</b></span>'))
    else:
        # Hitung rank
        rank_A = A_red.rank()
        total_var = nvars

        if rank_A == total_var:
            display(html('<b>Sistem mempunyai solusi tunggal:</b>'))
        elif rank_A < total_var:
            display(html(f'<b>Sistem mempunyai tak hingga solusi dengan {total_var - rank_A} variabel bebas:</b>'))
        else:
            display(html('<b>Sistem tidak dapat diselesaikan.</b>'))

        # Tampilkan solusi parametrik
        persamaan = [sum(c*v for c,v in zip(row, variables)) == val for row, val in zip(A_red, b_red)]
        sol = solve(persamaan, variables, solution_dict=True)

        if sol:
            show(sol[0])
        else:
            display(html('<b>Solusi dalam bentuk parametrik dapat ditulis tergantung variabel bebas.</b>'))
</script>
</div>
<hr>
<p align="justify">
Misalkan diberikan semua himpunan fungsi yaitu
</p>
$$
V=\{f:\mathbb{R}\rightarrow\mathbb{R}\}
$$
<p align="justify">
dan \(D\subset V\), dengan
</p>
$$
D=\left\{f\in V\:\left|\:\dfrac{d^2f}{dx^2}\right.+f=0\right\},
$$
<p align="justify">
Kita berikan himpunan \(D\) yang merupakan penyelesaian dari persamaan differensial:
</p>
$$
\dfrac{d^2f}{dx^2}+f=0
$$
<div id="pdb">
<script type="text/x-sage">
var('x')
f = function ('f')(x)
pd = diff (f,x,2)+f == 0

pretty_print(html(r"Himpunan penyelesaian dari $\frac{d^2f}{dx^2}\ \ +f=0$ adalah :"))
pretty_print(html(r"$D=\left\{ f(x) = %s \mid K_1,K_2\in\mathbb{R}\right\}$"%latex(expand(desolve(pd,f)))))
</script>
</div>
<hr>
	    
<p align="justify">
Diberikan
$$
|x\rangle=\begin{bmatrix}
1\\
i\\
2+i
\end{bmatrix}\ \text{dan}\ |y\rangle=\begin{bmatrix}
2-i\\
1\\
2+i
\end{bmatrix}.
$$
Dapatkan \(\||x\rangle\|, \langle x|y\rangle\) dan \(\langle y|x\rangle\). \(\square\).
<br>
Kita jawab permasalahan dalam Sel SageMath berikut:
</p>
<div id="jawab">
<script type="text/x-sage">
%display latex

s = vector([1,i,2+i])
w = vector([2-i,1,2+i])

x=s.column()
y=w.column()

w=s.conjugate()
h=w.inner_product(s)

A = x.conjugate_transpose()*y
B = y.conjugate_transpose()*x

pretty_print(html(r"$|x\rangle=%s$"%latex(x)))
pretty_print(html(r"$|y\rangle=%s$"%latex(y)))
pretty_print(html(r"$\||x\rangle\|=%s$"%latex(s.norm())))
pretty_print(html(r"$|x\rangle^{\dagger}=%s$"%latex(w.row())))
pretty_print(html(r"$\langle x|y\rangle=%s$"%latex(A)))
pretty_print(html(r"$\langle y|x\rangle=%s$"%latex(B)))
</script>
</div>

<hr>
<p align="justify">
Diberikan ruang vektor $\mathbb{R}^2$ atas lapangan $\mathbb{R}$ dan $\mathbb{Z}^2_5$ atas lapangan
berhingga $\mathbb{Z}_5$. Maka
</p>
	$$
    \pmb{u}=\begin{bmatrix}
    4\\ 3
    \end{bmatrix}\in\mathbb{R}^2
    $$
<p align="justify">dan</p>
$$
    \pmb{v}=\begin{bmatrix}
    4\\ 3
    \end{bmatrix}\in\mathbb{Z}_{5}^2.
    $$

<p align="justify">
Juga bisa ditunjukkan dalam <b>SageMath</b> bahwa $\pmb{u}\neq\pmb{v}$.
</p>

<div id="vputar">
<script type="text/x-sage">
R2=RR^2
Z5=GF(5)

u = vector(RR,[1/2,sqrt(2)]).column()
v = vector(Z5,[1,2]).column()

display(html(r"Himpunan $\mathbb{R}^2$ : %s"%R2))
display(html(r"Himpunan $\mathbb{Z}_{5}^2$ : %s"%Z5^2))

display(html(r"$\pmb{u} = %s\in\mathbb{R}^2$"%latex(u)))
display(html(r"$\pmb{v} = %s\in\mathbb{Z}_{5}^2$"%latex(v)))
display(html(r"$\pmb{u} \neq \pmb{v}? %s$"%latex(u!=v)))
</script>
</div>

</details>
<hr>


<h3>ğŸ“ <b>Membongkar Peran Aljabar Linear dalam Teknik Kriptografi Simulatif</b></h3>
<details>
<summary class="judul-kolaborasi">
   ğŸ“Š <b>Peran Aljabar Linier dalam Kriptografi</b>
</summary>
<p align="justify">
Kode berikut ini adalah <b>simulasi pertukaran kunci Diffie-Hellman (DH)</b> menggunakan 
<b>aljabar linear</b> di dalam <b>lapangan hingga (finite field)</b>, serta menerapkan 
<b>Caesar Cipher</b> untuk enkripsi pesan.
</p>
<p align="justify">
Berbeda dari kriptografi klasik berbasis bilangan prima besar atau kurva eliptik, 
simulasi ini menggunakan <b>operasi matriks modular</b> sebagai analogi.
</p>

<h2><b>1. Struktur Matematis yang Digunakan</b></h2>

<h3> ğŸ”¢ <b>Generator Matriks Acak</b></h3>
<ul align="justify">
<li> Matriks publik $G$ berukuran <b>$4\times 4$</b> (anda bisa mengganti dalam kode program), diisi bilangan acak dalam:

  $$
  \mathbb{Z}_{211} = \{0, 1, 2, \dotsc, 210\}
  $$
</li>
<li> 
    Matriks ini berperan sebagai dasar perhitungan kunci publik, mirip dengan <b>generator grup</b> dalam protokol DH standar.
</li>
</ul>

<h2><b>2. Alur Pertukaran Kunci</b></h2>

<h3> ğŸ” <b>Tahapan</b></h3>
<ul align="justify">
<li> Alice dan Bob masing-masing memilih bilangan privat $a$, $b$ secara acak:

  $$
  1 \leq a, b \leq 210
  $$
</li>
<li> Mereka menghitung kunci publik masing-masing:

  $$
  A = (a \times G) \mod 211 \\
  B = (b \times G) \mod 211
  $$
</li>
<li> Pertukaran publik dilakukan secara terbuka.</li>
<li> Perhitungan kunci bersama:

  $$
  K_1 = (a \times B) \mod 211 \quad
  K_2 = (b \times A) \mod 211
  $$

  Dengan sifat aljabar linear, kedua hasil seharusnya sama $(K_1 = K_2)$, mirip prinsip DH:

  $$
  a \times (b \times G) = b \times (a \times G)
  $$
</li>
</ul>

<h2><b>3. Enkripsi dan Dekripsi Pesan</b></h2>
<ul align="justify">
</li> Dari matriks kunci $K_1$, diambil:
  <ul align="justify">
  <li>Penjumlahan elemen diagonal utama:

    $$
    k\_raw = \sum_{i=0}^{5} K_1[i, i]
    $$
  </li>
  <li> Hasil diambil modulo 256 sebagai kunci sederhana untuk Caesar Cipher.</li>
  </ul>
<li> Proses enkripsi byte per byte:

  $$
  c_i = (p_i + k) \mod 256
  $$
</li>
<li> Proses dekripsi:

  $$
  p_i = (c_i - k) \mod 256
  $$
</li>
    Ini adalah simulasi konsep <b>enkripsi kunci simetris</b> menggunakan kunci yang dihasilkan oleh pertukaran DH 
    berbasis matriks.
</li>
</ul>

<h2> <b>4. Tujuan dan Aplikasi</b> </h2>
<ul align="justify">
<li> <b>Simulasi edukatif</b>, bukan sistem kriptografi untuk produksi.</li>
<li> Memberikan pemahaman tentang:
  <ul align="justify">
  <li> Kombinasi konsep aljabar linear.</li>
  <li> Operasi matriks modular di lapangan hingga.</li>
  <li> Konsep pertukaran kunci dan enkripsi sederhana.</li>
  </ul>
</li>
<li> Bisa dikembangkan untuk:
  <ul align="justify">
  <li> Matriks lebih besar (contoh $10\times 10$ atau lebih).</li>
  <li> Deteksi keamanan tambahan (sidik jari kunci publik).</li>
  <li> Visualisasi diagram komunikasi.</li>
  <li> Penggunaan enkripsi kuat seperti ChaCha20.</li>
  </ul>
</li>
</ul>

<h2><b>Kesimpulan</b></h2>
<p align="justify">
Kode ini menggabungkan:
</p>
<ul align="justify">
<li>âœ… Konsep aljabar linear matriks modular.</li>
<li>âœ… Simulasi Diffie-Hellman untuk kunci bersama.</li>
<li>âœ… Enkripsi sederhana Caesar Cipher.</li>
<li>âœ… Visual output interaktif di SageMath Cell.</li>
</ul>

<script src="https://sagecell.sagemath.org/static/embedded_sagecell.js"></script>
<script>
    sagecell.makeSagecell({
        inputLocation: "#sagemath-ecc1",
        template: sagecell.templates.default,    
        evalButtonText: "Jalankan Simulasi",
        linked: true
    });
</script>

<div id="sagemath-ecc1">
<textarea>
from random import randint
from sympy import Matrix
from sage.all import *

# Matriks publik generator acak ukuran 6x6
modulus = 211  # Bilangan prima untuk modulus (lapangan hingga)
n = 4  # Ukuran matriks
G = Matrix([[randint(1, modulus - 1) for _ in range(n)] for _ in range(n)])

def proses_kriptografi(pesan_input):
    try:
        if not isinstance(pesan_input, str):
            raise ValueError("Input harus berupa teks (string).")

        a = randint(1, modulus - 1)
        b = randint(1, modulus - 1)

        A = (a * G) % modulus
        B = (b * G) % modulus

        K1 = (a * B) % modulus
        K2 = (b * A) % modulus

        if K1 != K2:
            raise ValueError("Kunci bersama tidak cocok, periksa operasi matriks.")

        # Ekstraksi kunci sederhana dari elemen diagonal
        k_raw = sum(K1[i, i] for i in range(n))
        k = int(k_raw) % 256

        pesan_bytes = pesan_input.encode('utf-8')
        cipher_bytes = bytes([(x + k) % 256 for x in pesan_bytes])
        decrypted_bytes = bytes([(x - k) % 256 for x in cipher_bytes])
        pesan_terdekripsi = decrypted_bytes.decode('utf-8', errors='replace')
        pesan_terenkripsi = cipher_bytes.hex()

        def matrix_to_list(M):
            return [[int(M[i, j]) for j in range(M.ncols())] for i in range(M.nrows())]

        html_out = f"""
        <h3>ğŸ” Simulasi Kriptografi Hybrid (Linear Algebra DH + Caesar Cipher)</h3>
        <ul>
          <li><b>Kunci privat Alice:</b> {a}</li>
          <li><b>Kunci privat Bob:</b> {b}</li>
          <li><b>Kunci publik Alice (A):</b> {matrix_to_list(A)}</li>
          <li><b>Kunci publik Bob (B):</b> {matrix_to_list(B)}</li>
          <li><b>Kunci bersama (mod 256):</b> {k}</li>
        </ul>
        <p><b>Pesan asli:</b> {pesan_input}</p>
        <p><b>Pesan terenkripsi (hex):</b><br><code>{pesan_terenkripsi}</code></p>
        <p><b>Pesan terdekripsi:</b> {pesan_terdekripsi}</p>
        <p><b>Status:</b> {"âœ… Berhasil!" if pesan_input == pesan_terdekripsi else "ğŸ§¬ğŸ›‘ Gagal! Pesan tidak cocok."}</p>
        """
        show(html(html_out))
        
    except Exception as e:
        show(html(f"<p style='color:red'><b>âŒ Error saat enkripsi:</b> {e}</p>"))

# Interaktif untuk SageMath Cell
@interact
def _(pesan=input_box(default="Pesan rahasia kita berdua ğŸ’–ğŸ’˜ãƒœãƒ–ã€æ„›ã—ã¦ã‚‹ Untuk Bob!", label="ğŸ“© Pesan Alice", type=str, rows=8),
     kirim=checkbox(False, label="âœ… Kirim Pesan?")):
    if kirim:
        proses_kriptografi(pesan)
</textarea>
</div>


<h2> ğŸ“– <b>Simulasi Serangan Kriptografi Menggunakan Matriks Modular, MITM, dan Brute-Force</b></h2>

<h2> <b>1. Latar Belakang</b></h2>

<h3> <b>1.1. Kriptografi dan Pertukaran Kunci </b></h3>
<p align="justify">
Dalam sistem komunikasi modern, keamanan informasi bergantung pada kemampuan dua pihak (Alice dan Bob) 
untuk saling bertukar pesan rahasia tanpa bocor ke pihak ketiga (Eve). Salah satu pendekatan klasik adalah 
<b>pertukaran kunci berbasis operasi linier modular</b>, di mana:
</p>
<ul align="justify">
<li> Matriks generator $G$ dibuat acak berdimensi $n \times n$ dengan entri di ruang $\mathbb{Z}_{p}$, 
    yaitu bilangan bulat modulo $p$.
</li>
<li> Setiap pihak memiliki kunci privat bilangan bulat $a, b, e$ dipilih acak dalam $[1, p-1]$.</li>
<li> Kunci publik dihitung sebagai $A_{\text{pub}} = a \cdot G \mod p$ dan seterusnya.</li>
</ul>
<p align="justify">
Prinsip ini terinspirasi dari protokol Diffie-Hellman namun dimodifikasi ke ranah operasi matriks, 
yang populer dalam kriptografi berbasis struktur aljabar linier.
</p>

<h3> <b>1.2. Operasi Modular dan Keamanan</b></h3>
<p align="justify">
Modular arithmetic digunakan untuk:
</p>
<ul align="justify">
<li> Membatasi ruang nilai, mencegah hasil tak terhingga.</li>
<li> Memberikan sifat <i>wrap-around</i>, sehingga operasi tidak linear di ruang bilangan real.</li>
<li> Menghambat rekonstruksi langsung kunci privat jika hanya diketahui kunci publik.</li>
</ul>

<h3> <b>1.3. Ekstraksi Kunci Rahasia</b> </h3>
<p align="justify">
Kunci rahasia diekstrak dari hasil matriks:
</p>
<ul align="justify">
<li> Mengambil jumlah diagonal utama.</li>
<li> Menambahkan diagonal sekunder (anti-diagonal).</li>
<li> Menjumlah elemen tepi (border sum).</li>
<li> Hasil akhir direduksi modulo 256 agar sesuai ruang byte (karakter).</li>
</ul>
<p align="justify">
Hasil kunci ini digunakan untuk proses enkripsi/dekripsi simetris berbasis penambahan dan pengurangan byte.
</p>

<h2> <b>2. Alur dan Maksud Program</b> </h2>
<p align="justify">
Program ini terdiri dari dua simulasi serangan utama:
</p>
<h3> <b>2.1. Serangan <i>Man-in-the-Middle (MITM)</i> oleh Eve</b></h3>
<ul align="justify">
<li> Eve menyusup jalur komunikasi Alice dan Bob.</li>
<li> Eve <b>memalsukan kunci publik Bob</b> yang diterima Alice.</li>
<li> Alice menghitung kunci bersama dengan Eve tanpa sadar.</li>
<li> Eve mampu:
  <ul align="justify">
  <li> Menghitung kunci yang sama dengan Alice.</li>
  <li> Membuka pesan rahasia yang Alice kirim.</li>
  </ul>
</li>
<li> Bob tetap menghitung kunci dengan benar, tetapi karena jalur kunci sudah dibelokkan, dia mungkin menerima pesan rusak.</li>
</ul>
<p align="justify">
<b>Kesimpulan:</b> MITM efektif jika Eve mampu mengendalikan jalur distribusi kunci publik.
</p>

<h3> <b>2.2. Simulasi <i>Brute-Force Attack</i></b></h3>
<ul align="justify">
<li> Eve <b>tidak menyusup</b>, hanya memantau pesan terenkripsi.</li>
<li> Dia mencoba semua kemungkinan $k$ dalam $[0, 255]$ untuk mendekripsi pesan.</li>
<li> Jika hasil dekripsi cocok dengan pesan asli, brute-force dinyatakan sukses.</li>
</ul>
<p align="justify">
<b>Catatan:</b> Brute-force menjadi feasibel karena:
</p>
<ul align="justify">
<li> Ruang kunci hanya 256 kemungkinan (modulo 256).</li>
<li> Tidak ada mekanisme autentikasi tambahan atau perpanjangan kunci yang memperbesar ruang kunci.</li>
</ul>

<h2> <b>3. Prinsip Serangan Eve dan Brute-Force</b> </h2>

<center>

    <table border="1" style="border-collapse:collapse; width:90%; text-align:center; font-family:Arial; box-shadow: 2px 2px 8px #bbb">
<thead style="background-color:#37474F; color:white">
<tr>
  <th>Aspek</th>
  <th style="background-color:#0277BD">Man-in-the-Middle (MITM)</th>
  <th style="background-color:#C62828">Brute-Force Attack</th>
</tr>
</thead>
<tbody>
<tr style="background-color:#f0f7ff">
  <td><b>Akses ke Jalur</b></td>
  <td>Eve harus menyusup jalur komunikasi</td>
  <td>Eve hanya menangkap ciphertext</td>
</tr>
<tr>
  <td><b>Keterampilan</b></td>
  <td>Mengontrol atau memalsukan kunci publik</td>
  <td>Mencoba semua kemungkinan kunci</td>
</tr>
<tr style="background-color:#f0f7ff">
  <td><b>Risiko</b></td>
  <td>Bisa ketahuan jika jalur diawasi</td>
  <td>Tidak terdeteksi, tapi memakan waktu</td>
</tr>
<tr>
  <td><b>Efisiensi</b></td>
  <td>Sangat efektif jika jalur dikuasai</td>
  <td>Bergantung ukuran ruang kunci</td>
</tr>
<tr style="background-color:#f0f7ff">
  <td><b>Matematika</b></td>
  <td>Manipulasi matriks modular & kunci</td>
  <td>Eksploitasi kelemahan ruang kunci kecil</td>
</tr>
</tbody>
</table>

</center>


<h2> <b>4. Keunggulan Program Ini</b></h2>
<ul align="justify">
<li> Mensimulasikan kondisi realistis serangan MITM.</li>
<li> Memvisualisasi dampak manipulasi kunci publik.</li>
<li> Menguji efektivitas brute-force dalam lingkungan modular terbatas.</li>
<li> Memberikan insight probabilistik keberhasilan kedua serangan.</li>
</ul>

<h2> <b>5. Catatan Tambahan</b></h2>
<ul align="justify">
<li> Ruang kunci hanya 256 kemungkinan membuat brute-force masih realistis.</li>
<li> Dalam implementasi nyata, kunci perlu diperluas agar brute-force tidak praktis.</li>
<li> Matriks modular memperluas struktur aljabar, cocok untuk eksperimen protokol berbasis Linear Algebra over 
Finite Fields (LAFF).</li>
<li> Serangan MITM menegaskan pentingnya autentikasi kunci publik, seperti melalui infrastruktur Public Key 
Infrastructure (PKI) atau tanda tangan digital.</li>
</ul>

<h2> <b>6. Potensi Pengembangan</b></h2>
<ul align="justify">
<li> Menambah autentikasi berbasis hash atau tanda tangan digital.</li>
<li> Menggunakan ruang kunci lebih besar untuk menghambat brute-force.</li>
<li> Mensimulasikan serangan side-channel atau analisis diferensial.</li>
</ul>


<h2> ğŸ¯ <b>Kesimpulan</b></h2>

<b>Program ini merepresentasikan dua skenario serangan:</b>
<ul align="justify">
<li>âœ… MITM: Sangat berbahaya jika distribusi kunci tidak aman.</li>
<li>âœ… Brute-force: Masih efektif jika ruang kunci terlalu kecil.</li>
</ul>
<p align="justify">
Simulasi ini memberikan pemahaman matematis dan praktis terhadap keamanan kriptografi berbasis matriks modular, 
sekaligus mengedukasi tentang pentingnya pengamanan jalur distribusi kunci.
</p>


<h2> ğŸ“Œ <b>Konstruksi Kunci pada Program: Publik, Privat, Simetri, atau Asimetri</b></h2>

<h2> <b>1. Jenis Kunci dan Statusnya</b></h2>

<center>
<table border="1" style="border-collapse:collapse; text-align:center; width:80%; font-family:Arial; box-shadow:2px 2px 10px #cccccc">
<thead style="background-color:#df2d74; color:rgb(255, 255, 255)">
<tr>
  <th>Kunci</th>
  <th>Peran</th>
  <th>Publik/Privat</th>
  <th>Simetri/Asimetri</th>
</tr>
</thead>
<tbody>
<tr>
  <td><b><i>a</i></b> (Alice)</td>
  <td>Kunci privat milik Alice</td>
  <td>Privat</td>
  <td>Asimetri</td>
</tr>
<tr>
  <td><b><i>b</i></b> (Bob)</td>
  <td>Kunci privat milik Bob</td>
  <td>Privat</td>
  <td>Asimetri</td>
</tr>
<tr>
  <td><b><i>e</i></b> (Eve)</td>
  <td>Kunci privat milik Eve</td>
  <td>Privat</td>
  <td>Asimetri</td>
</tr>
<tr>
  <td><b>$G$</b></td>
  <td>Matriks generator publik</td>
  <td>Publik</td>
  <td>Asimetri</td>
</tr>
<tr>
  <td><b>$A_{\text{pub}} = a\times G \mod p$</b></td>
  <td>Kunci publik Alice</td>
  <td>Publik</td>
  <td>Asimetri</td>
</tr>
<tr>
  <td><b>$B_{\text{pub}} = b\times G \mod p$</b></td>
  <td>Kunci publik Bob</td>
  <td>Publik</td>
  <td>Asimetri</td>
</tr>
<tr>
  <td><b>$E_{\text{pub}} = e\times G \mod p$</b></td>
  <td>Kunci publik Eve</td>
  <td>Publik</td>
  <td>Asimetri</td>
</tr>
<tr>
  <td><b>$k_{\text{shared}}$</b></td>
  <td>Kunci rahasia hasil perhitungan bersama</td>
  <td>Simetris</td>
  <td>Simetri</td>
</tr>
</tbody>
</table>
</center>


<h2> <b>2. Penjelasan Detail</b> </h2>

<h3> <b>2.1. Kunci Privat</b></h3>
<ul align="justify">
<li> $a, b, e$ adalah bilangan acak rahasia dipilih masing-masing pihak.</li>
<li> Tidak boleh dibagikan ke pihak lain.</li>
<li> Berperan mirip kunci privat pada protokol Diffie-Hellman klasik.</li>
</ul>

<h3> <b>2.2. Kunci Publik</b></h3>
<ul align="justify">
<Li> $G$ adalah matriks publik, diketahui semua pihak.</Li>
<li> $A_{\text{pub}}, B_{\text{pub}}, E_{\text{pub}}$ adalah kunci publik yang dibagikan ke lawan bicara.</li>
<li> Perhitungan:

  $$
  A_{\text{pub}} = a \times G \mod p
  $$

  dan seterusnya.
</li>
<li> <b>Asimetri:</b> Informasi kunci publik tidak cukup untuk membalik ke kunci privat, asumsi dasar keamanan.</li>
</ul>

<h3> <b>2.3. Kunci Simetris</b></h3>
<ul align="justify">
<li>Setelah pertukaran kunci publik, pihak-pihak menghitung kunci bersama dari kombinasi kunci publik dan privat.</li>
<li> Contoh:
  <ul align="justify">
  <li>Alice menghitung:

    $$
    K_{AE} = a \times E_{\text{pub}} \mod p
    $$
  </li>
  <li> Eve menghitung:

    $$
    K_{EA} = e \times A_{\text{pub}} \mod p
    $$
  </li>
  <li> Idealnya, hasil ekstraksi dari $K_{AE}$ dan $K_{EA}$ sama, yaitu kunci simetris untuk enkripsi-dekripsi.</li>
  </ul>
</li>
<li> Kunci simetris ini dipakai untuk enkripsi sederhana berbasis penambahan-pengurangan byte:

  $$
  \text{cipher}[i] = (\text{plaintext}[i] + k_{\text{shared}}) \mod 256
  $$

  $$
  \text{plaintext}[i] = (\text{cipher}[i] - k_{\text{shared}}) \mod 256
  $$
</li>
</ul>

<h2> <b>3. Simetri vs Asimetri dalam Program Ini</b></h2>
<center>

<table border="1" style="border-collapse:collapse; text-align:center; width:80%; font-family:Arial; box-shadow:2px 2px 10px #ccc">
<thead style="background-color:#2d6cdf; color:white">
<tr>
  <th>Aspek</th>
  <th style="background-color:#4CAF50">Simetri</th>
  <th style="background-color:#FF5722">Asimetri</th>
</tr>
</thead>
<tbody>
<tr style="background-color:#f0f7ff">
  <td>Pertukaran kunci</td>
  <td>Asimetri (gunakan publik-privat)</td>
  <td>-</td>
</tr>
<tr>
  <td>Kunci akhir enkripsi</td>
  <td>Simetri (dipakai dua arah, sama)</td>
  <td>-</td>
</tr>
<tr style="background-color:#f0f7ff">
  <td>Serangan MITM</td>
  <td>-</td>
  <td>Manfaatkan kelemahan distribusi publik (asimetri)</td>
</tr>
<tr>
  <td>Brute-force</td>
  <td>Eksploitasi kelemahan kunci simetris kecil</td>
  <td>-</td>
</tr>
</tbody>
</table>

</center>

<h2> <b>4. Catatan Penting</b></h2>
<ul align="justify">
<li> Sistem ini <b>bukan murni sistem kunci publik seperti RSA atau ECC</b>, karena:
  <ul align="justify">
  <li> Tidak ada prosedur verifikasi tanda tangan digital.</li>
  <li> Tidak ada sertifikat kunci.</li>
  <li> Keamanan hanya bergantung pada rahasia kunci privat dan distribusi publik yang aman.</li>
  </ul>
</li>
<li> Skema mirip Diffie-Hellman Matrix-based, namun tidak sekuat bila diterapkan tanpa modifikasi keamanan tambahan.</li>

</ul>

<h2> ğŸ¯ <b>Kesimpulan</b></h2>
<ul align="justify">
<li> Program ini menggunakan kombinasi <b>asimetri untuk pertukaran kunci</b> dan <b>simetri untuk enkripsi-dekripsi</b>.</li>
<li> Serangan MITM berhasil karena Eve dapat memalsukan kunci publik tanpa autentikasi.</li>
<li> Brute-force menyerang kelemahan ruang kunci simetris yang kecil.</li>

</ul>

<script src="https://sagecell.sagemath.org/static/embedded_sagecell.js"></script>
<script>
    sagecell.makeSagecell({
        inputLocation: "#sagemath-ecc2",
        template: sagecell.templates.default,    
        evalButtonText: "ğŸ” Jalankan Simulasi"
    });
</script>

<div id="sagemath-ecc2">
<textarea>
from random import randint
from sympy import Matrix
from sage.all import *

modulus = 211
n = 8
G = Matrix([[randint(1, modulus - 1) for _ in range(n)] for _ in range(n)])

def ekstrak_kunci(K):
    diagonal_sum = sum(K[i, i] for i in range(n))
    anti_diag_sum = sum(K[i, n - 1 - i] for i in range(n))
    border_sum = sum(K[0, j] + K[n - 1, j] for j in range(n)) + sum(K[i, 0] + K[i, n - 1] for i in range(1, n - 1))
    return int(diagonal_sum + anti_diag_sum + border_sum) % 256

def satu_simulasi(pesan_input):
    a = randint(1, modulus - 1)
    b = randint(1, modulus - 1)
    e = randint(1, modulus - 1)

    A_pub = (a * G) % modulus
    B_pub = (b * G) % modulus
    E_pub = (e * G) % modulus

    B_pub_palsu = E_pub

    K_alice_eve = (a * B_pub_palsu) % modulus
    k_shared = ekstrak_kunci(K_alice_eve)

    K_eve_alice = (e * A_pub) % modulus
    k_eve = ekstrak_kunci(K_eve_alice)

    K_ab_1 = (a * B_pub) % modulus
    k_ab = ekstrak_kunci(K_ab_1)

    pesan_bytes = pesan_input.encode('utf-8')
    cipher_bytes = bytes([(x + k_shared) % 256 for x in pesan_bytes])
    decrypted_by_eve = bytes([(x - k_eve) % 256 for x in cipher_bytes]).decode('utf-8', errors='replace')
    decrypted_by_bob = bytes([(x - k_ab) % 256 for x in cipher_bytes]).decode('utf-8', errors='replace')

    bob_berhasil = decrypted_by_bob == pesan_input
    eve_berhasil = decrypted_by_eve == pesan_input and not bob_berhasil

    return eve_berhasil, bob_berhasil, decrypted_by_eve, decrypted_by_bob, cipher_bytes.hex(), pesan_bytes

def brute_force_attack(cipher_bytes, pesan_asli_bytes):
    for k_coba in range(256):
        hasil = bytes([(x - k_coba) % 256 for x in cipher_bytes])
        if hasil == pesan_asli_bytes:
            return True, k_coba  # Berhasil, ketemu kunci k_coba
    return False, None

def proses_simulasi_aktif(pesan_input, m=1):
    try:
        m = int(m)
        if m < 1:
            m = 1

        eve_berhasil_count = 0
        bob_berhasil_count = 0
        brute_berhasil_count = 0

        contoh_pesan_eve = "(Tidak ada yang berhasil)"
        contoh_pesan_bob_rusak = "(Tidak ada pesan rusak)"
        contoh_cipher = ""
        contoh_kunci_brute = None

        for _ in range(m):
            eve_berhasil, bob_berhasil, decrypted_by_eve, decrypted_by_bob, cipher_hex, pesan_bytes = satu_simulasi(pesan_input)
            cipher_bytes = bytes.fromhex(cipher_hex)

            if eve_berhasil_count == 0 and eve_berhasil:
                contoh_pesan_eve = decrypted_by_eve
                contoh_cipher = cipher_hex

            if bob_berhasil_count == 0 and not bob_berhasil:
                contoh_pesan_bob_rusak = decrypted_by_bob
                contoh_cipher = cipher_hex

            if eve_berhasil:
                eve_berhasil_count += 1
            if bob_berhasil:
                bob_berhasil_count += 1

            # Brute-force selalu dilakukan, terlepas dari MITM
            berhasil_brute, k_brute = brute_force_attack(cipher_bytes, pesan_bytes)
            if berhasil_brute:
                brute_berhasil_count += 1
                if contoh_kunci_brute is None:
                    contoh_kunci_brute = k_brute

        prob_eve = (eve_berhasil_count / m) * 100
        prob_bob = (bob_berhasil_count / m) * 100
        prob_brute = (brute_berhasil_count / m) * 100

        kunci_brute_info = f"{contoh_kunci_brute}" if contoh_kunci_brute is not None else "(Tidak ditemukan)"

        html_out = f"""
        <h3>ğŸ” Simulasi Serangan Eve (Man-in-the-Middle) + Brute-Force</h3>
        <ul>
          <li><b>Total Percobaan:</b> {m}</li>
          <li><b>Probabilitas Eve berhasil membuka pesan (MITM):</b> {float(prob_eve):.2f}%</li>
          <li><b>Probabilitas Bob menerima pesan utuh:</b> {float(prob_bob):.2f}%</li>
          <li><b>Probabilitas Brute-Force berhasil:</b> {float(prob_brute):.2f}%</li>
        </ul>
        <p><b>Pesan asli yang dikirim Alice:</b> {pesan_input}</p>
        <p><b>Contoh ciphertext (HEX):</b><br><code>{contoh_cipher}</code></p>
        <p><b>Contoh pesan yang berhasil dibaca Eve (saat Bob gagal):</b> {contoh_pesan_eve}</p>
        <p><b>Contoh pesan rusak yang diterima Bob:</b> {contoh_pesan_bob_rusak}</p>
        <p><b>Contoh kunci brute-force yang ditemukan:</b> {kunci_brute_info}</p>
        """
        show(html(html_out))

    except Exception as e:
        show(html(f"<p style='color:red'><b>âŒ Error:</b> {e}</p>"))

# Interaktif SageMath Cell
@interact
def _(pesan=input_box(default="Pesan rahasia ğŸ’–æˆ‘çˆ±ä½ ï¼Œé²å‹ƒ Untuk Bob!", label="ğŸ“© Pesan Alice", type=str, rows=10),
     percobaan=slider(1, 500, 1, default=10, label="ğŸ” Jumlah Percobaan"),
     mulai=checkbox(False, label="âœ… Jalankan Simulasi?")):
    if mulai:
        proses_simulasi_aktif(pesan, percobaan)
</textarea>
</div>
<hr>

<h2>ğŸ“‘ <b>Simulasi Aljabar-Linear Diffie-Hellman dengan Deteksi Sidik Jari</b></h2>

<h3><b>1. Pengantar</b></h3>
<p align="justify">
Dalam era komunikasi digital modern, kebutuhan akan protokol pertukaran kunci yang aman semakin krusial, 
terutama untuk mencegah serangan seperti man-in-the-middle (MitM). Salah satu fondasi utama yang sering 
digunakan adalah Diffie-Hellman Key Exchange, yang secara tradisional berbasis aritmetika modular bilangan skalar.
</p>
<p align="justify">
Dokumen ini memaparkan implementasi inovatif simulasi Diffie-Hellman berbasis Aljabar Linier, 
memanfaatkan matriks modular sebagai elemen kunci publik, serta dilengkapi mekanisme deteksi 
manipulasi berbasis sidik jari kriptografis menggunakan algoritma hash SHA-256.
</p>

<h3><b>2. Landasan Teoretis</b></h3>

<h4> <b>2.1. Matriks Modular sebagai Ruang Kunci</b></h4>
<p>
Diberikan:
</p>
$$
G \in \mathbb{Z}_p^{n \times n}
$$
<p>
di mana:
</p>
<ul align="justify">
<li> $G$ adalah matriks acak generator publik,</li>
<li> $\mathbb{Z}_p$ adalah ruang bilangan bulat modulo $p$, dengan $p$ bilangan prima untuk menjamin 
properti aritmetika modular,</li>
<li> $n$ adalah ukuran dimensi matriks (pada simulasi: $n = 8$).</li>
</ul>
<p align="justify">
Pemanfaatan matriks sebagai representasi kunci publik memperluas kompleksitas spasial dan 
meningkatkan kemungkinan varian pertukaran kunci yang lebih sulit dianalisis secara brute-force.
</p>

<h4> <b>2.2. Protokol Linear Algebra Diffie-Hellman</b></h4>
<p align="justify">
Setiap pihak menghasilkan kunci sebagai:
</p>
$$
A_{\text{pub}} = a \times G \mod p, \quad B_{\text{pub}} = b \times G \mod p
$$
<p align="justify">
di mana $a, b \in \mathbb{Z}_p^*$ adalah bilangan rahasia privat masing-masing pihak. Setelah pertukaran, 
kunci bersama dihitung:
</p>
$$
K_{\text{shared}} = a \times B_{\text{pub}} \mod p = b \times A_{\text{pub}} \mod p
$$
<p align="justify">
Asumsi keamanan bergantung pada kesulitan masalah logaritma diskret dalam ruang matriks modular, 
meskipun implementasi ini bersifat edukatif, bukan protokol kriptografi standar industri.
</p>

<h4> <b>2.3. Deteksi Manipulasi melalui Sidik Jari Hash</b></h4>
<p align="justify">
Integritas data dicek melalui fungsi:
</p>
$$
\text{Fingerprint}(M) = \text{SHA256}(\text{Stringify}(M))[:8]
$$
<p align="justify">
Proses ini mengubah representasi matriks menjadi string deterministik, kemudian menghasilkan 
<i>hash fingerprint</i> sepanjang 8 karakter heksadesimal sebagai verifikasi keaslian data selama transmisi.
</p>

<h3> <b>3. Alur Simulasi dan Visualisasi</b></h3>

<h4> <b>3.1. Generasi Kunci</b></h4>
<ul align="justify">
<li> Alice, Bob, dan Eve (penyerang) masing-masing menghasilkan matriks publik.</li>
<li> Matriks generator $G$ tetap publik untuk semua pihak.</li>
</ul>

<h4><b>3.2. Simulasi Serangan</b></h4>
<p align="justify">
Dengan probabilitas $50\%$, Eve dapat memanipulasi jalur komunikasi:
</p>
  <ul align="justify">
  <li> Jika manipulasi terjadi, Alice menerima $E_{\text{pub}}$ alih-alih $B_{\text{pub}}$.</li>
  <li> Sidik jari diverifikasi untuk mendeteksi ketidaksesuaian.</li>
  </ul>
<h4> <b>3.3. Ekstraksi dan Enkripsi Pesan</b></h4>
<p align="justify">
Jika jalur aman:
</p>
<ol align="justify">
<li> Alice menghitung kunci bersama.</li>
<li> Nilai skalar diekstrak dari elemen-elemen penting matriks: diagonal utama, anti-diagonal, serta tepi matriks.</li>
<li> Pesan asli dienkripsi menggunakan operasi substitusi sederhana berbasis kunci modulo 256.</li>
</ol>

<h4> <b>3.4. Visualisasi Interaktif</b></h4>
<p align="justify">
Diagram SVG ditampilkan menunjukkan jalur komunikasi:
</p>
<ul align="justify">
<li> Warna <b>hijau</b> â†’ jalur aman ke Bob.</li>
<li> Warna <b>merah</b> â†’ manipulasi terdeteksi, jalur dialihkan ke Eve.</li>
<li> Hash fingerprint disertakan sebagai bukti autentikasi publik.</li>
</ul>

<h3> <b>4. Studi Kasus Simulasi</b></h3>
<p align="justify">
<b>Tanpa Serangan:</b>
</p>
<ul align="justify">
<li> Jalur Alice â†’ Bob berwarna hijau.</li>
<li> Sidik jari cocok.</li>
<li> Pesan terenkripsi dikirim dengan kunci bersama.</li>
</ul>
<p align="justify">
<b>Dengan Serangan:</b>
</p>
<ul align="justify">
<li> Jalur dialihkan ke Eve.</li>
<li> Fingerprint tidak cocok.</li>
<li> Sistem membatalkan komunikasi, menunjukkan deteksi serangan.</li>
</ul>

<h3> <b>5. Implikasi dan Rekomendasi</b></h3>
<p align="justify">
Meskipun implementasi ini tidak ditujukan untuk lingkungan produksi, simulasi ini memberikan:
</p>
<ul align="justify">
<li>âœ… Pemahaman dasar protokol pertukaran kunci berbasis aljabar linier.</li>
<li>âœ… Ilustrasi visual terhadap ancaman manipulasi data.</li>
<li>âœ… Demonstrasi fungsi hash sebagai alat integritas.</li>
<li>âœ… Penghubung konsep matematis abstrak ke dalam aplikasi nyata.</li>
</ul>
<p align="justify">
Untuk implementasi nyata di dunia industri, perlu dipertimbangkan:
</p>
<ul align="justify">
<li> Ukuran matriks lebih besar untuk meningkatkan kompleksitas.</li>
<li> Penggunaan lapangan bilangan prima yang jauh lebih besar.</li>
<li> Ekstraksi kunci dengan algoritma yang lebih kuat dan standar.</li>
<li> Penyesuaian fungsi hash sesuai kebutuhan keamanan.</li>
</ul>

<h3> <b>6. Kesimpulan</b></h3>
<p align="justify">
Simulasi ini menawarkan pengalaman belajar interaktif mengenai prinsip pertukaran kunci aman, 
ancaman manipulasi, dan deteksi integritas data berbasis hash. Dengan integrasi aljabar linier, 
pengguna diperkenalkan ke konsep kriptografi modern yang memperluas cakupan pembelajaran matematika 
ke dalam domain keamanan siber.
</p>

<h3> <b>7. Kode dan Eksperimen</b></h3>
<p align="justify">
Kode ini sepenuhnya terintegrasi dengan platform interaktif seperti <b>SageMathCell</b>, memanfaatkan:
</p>
<ul align="justify">
<li> <code>sympy</code> untuk manipulasi matriks simbolik,</li>
<li> <code>hashlib</code> untuk hash fingerprint,</li>
<li> <code>sage.all</code> untuk komputasi modular,</li>
<li> <code>interact</code> untuk antarmuka eksperimen dinamis.</li>
</ul>


<script src="https://sagecell.sagemath.org/static/embedded_sagecell.js"></script>
<script>
    sagecell.makeSagecell({
        inputLocation: "#sagemath-ecc3",
        template: sagecell.templates.default,    
        evalButtonText: "â–¶ï¸ Jalankan Simulasi"
    });
</script>

<div id="sagemath-ecc3">
<textarea>
from random import randint
from sympy import Matrix
from hashlib import sha256
from sage.all import *

modulus = 211
n = 8
G = Matrix([[randint(1, modulus - 1) for _ in range(n)] for _ in range(n)])

def matrix_to_string(M):
    return "".join(str(int(M[i, j])) for i in range(n) for j in range(n))

def sidik_jari(M):
    data = matrix_to_string(M).encode('utf-8')
    return sha256(data).hexdigest()[:8]  # 8 karakter ringkas

def ekstrak_kunci(K):
    diagonal_sum = sum(K[i, i] for i in range(n))
    anti_diag_sum = sum(K[i, n - 1 - i] for i in range(n))
    border_sum = sum(K[0, j] + K[n - 1, j] for j in range(n)) + sum(K[i, 0] + K[i, n - 1] for i in range(1, n - 1))
    return int(diagonal_sum + anti_diag_sum + border_sum) % 256

def proses_simulasi_aman(pesan_input):
    try:
        a, b, e = randint(1, modulus - 1), randint(1, modulus - 1), randint(1, modulus - 1)
        A_pub, B_pub, E_pub = (a * G) % modulus, (b * G) % modulus, (e * G) % modulus

        sidik_A = sidik_jari(A_pub)
        sidik_B_asli = sidik_jari(B_pub)
        sidik_E = sidik_jari(E_pub)

        manipulasi = randint(0, 1)
        B_pub_terima = E_pub if manipulasi else B_pub
        sidik_B_terima = sidik_jari(B_pub_terima)

        serangan_terdeteksi = sidik_B_asli != sidik_B_terima
        deteksi = "âœ… Aman, sidik jari cocok." if not serangan_terdeteksi else "ğŸ’¥ Terindikasi serangan, sidik jari tidak cocok!"

        # Diagram Jalur SVG
        warna = "green" if not serangan_terdeteksi else "red"
        label_jalur = "Bob" if not manipulasi else "Eve â†’ Bob"
        sidik_jalur = sidik_B_asli if not manipulasi else sidik_E

        svg_diagram = f"""
        <svg width="400" height="120" style="border:1px solid #ccc;">
          <circle cx="50" cy="60" r="20" fill="#add8e6"/><text x="40" y="65" font-size="12">Alice</text>
          <circle cx="350" cy="30" r="20" fill="#90ee90"/><text x="340" y="35" font-size="12">Bob</text>
          <circle cx="350" cy="90" r="20" fill="#f08080"/><text x="340" y="95" font-size="12">Eve</text>
          <line x1="70" y1="60" x2="330" y2="{30 if not manipulasi else 90}" stroke="{warna}" stroke-width="2" marker-end="url(#arrow)"/>
          <defs>
            <marker id="arrow" markerWidth="10" markerHeight="10" refX="5" refY="3" orient="auto">
              <path d="M0,0 L0,6 L9,3 z" fill="{warna}"/>
            </marker>
          </defs>
          <text x="180" y="{50 if not manipulasi else 80}" font-size="12" fill="{warna}">Publik {label_jalur}: {sidik_jalur}</text>
        </svg>
        """

        if serangan_terdeteksi:
            html_out = f"""
            <h3>ğŸ”’ Simulasi Aman Linear Algebra DH dengan Deteksi</h3>
            {svg_diagram}
            <ul>
              <li><b>Sidik jari Alice:</b> {sidik_A}</li>
              <li><b>Sidik jari Bob (asli):</b> {sidik_B_asli}</li>
              <li><b>Sidik jari diterima Alice:</b> {sidik_B_terima}</li>
              <li><b>Sidik jari Eve:</b> {sidik_E}</li>
            </ul>
            <p><b>Status Deteksi:</b> {deteksi}</p>
            <p style='color:red'><b> Proses dibatalkan, komunikasi tidak aman!</b></p>
            """
            show(html(html_out))
            return

        K_alice = (a * B_pub_terima) % modulus
        k_shared = ekstrak_kunci(K_alice)

        pesan_bytes = pesan_input.encode('utf-8')
        cipher_bytes = bytes([(x + k_shared) % 256 for x in pesan_bytes])
        pesan_terenkripsi = cipher_bytes.hex()

        html_out = f"""
        <h3>ğŸ”’ Simulasi Aman Linear Algebra DH dengan Deteksi</h3>
        {svg_diagram}
        <ul>
          <li><b>Sidik jari Alice:</b> {sidik_A}</li>
          <li><b>Sidik jari Bob (asli):</b> {sidik_B_asli}</li>
          <li><b>Sidik jari diterima Alice:</b> {sidik_B_terima}</li>
          <li><b>Sidik jari Eve:</b> {sidik_E}</li>
        </ul>
        <p><b>Status Deteksi:</b> {deteksi}</p>
        <p><b>Pesan asli:</b> {pesan_input}</p>
        <p><b>Pesan terenkripsi:</b><br><code>{pesan_terenkripsi}</code></p>
        """
        show(html(html_out))

    except Exception as e:
        show(html(f"<p style='color:red'><b>âŒ Error:</b> {e}</p>"))

@interact
def _(pesan=input_box(default="Pesan rahasia kita berdua ğŸ’–ğŸ’˜ãƒœãƒ–ã€æ„›ã—ã¦ã‚‹ Untuk Bob!", label="ğŸ“© Pesan Alice", type=str, rows=6),
     kirim=checkbox(False, label="âœ… Kirim Pesan?")):
    if kirim:
        proses_simulasi_aman(pesan)
</textarea>
</div>

<hr>        

<h2>ğŸ” Simulasi Komunikasi Aman Berbasis Matriks Modular dengan Penguatan Sidik Jari</h2>

<h3>1ï¸âƒ£ Konteks Matematika</h3>
<p align="justify">
Simulasi ini meniru sistem komunikasi aman antara dua pihak, <b>Alice</b> dan <b>Bob</b>, dalam kehadiran pihak ketiga 
yang berpotensi jahat, Eve. Fondasi matematis utamanya adalah operasi matriks, aritmetika modular, 
dan fungsi hash kriptografis. Sistem ini mengadaptasi konsep pertukaran kunci publik-privat, mirip Diffie-Hellman, 
namun menggunakan representasi matriks dan penambahan noise untuk meniru ketidakpastian saluran komunikasi.
</p>

<h3>2ï¸âƒ£ Matriks Generator dan Aritmetika Modular</h3>
<ul align="justify">
<li><b>Matriks Generator ($G$)</b>: Matriks acak berukuran $n\times n$ dengan elemen dari $\mathbb{Z}_p$, 
    ruang bilangan bulat modulo <b>$p = 65537$</b> (bilangan prima besar).</li>
<li><b>Operasi Modular</b>: Semua perhitungan dilakukan <i>modulo</i> <b>$p$</b> untuk menjaga hasil 
    tetap dalam ruang terbatas dan mencegah overflow.</li>
</ul>

<h3>3ï¸âƒ£ Penambahan Noise</h3>
<p align="justify">
  Fungsi <code>tambahkan_noise</code> menyimulasikan gangguan saluran komunikasi dengan menambahkan nilai 
  acak ke sebagian elemen matriks, dikontrol oleh parameter tingkat noise <b>Î· âˆˆ [0,1]</b>.
</p>

<h3>4ï¸âƒ£ Sidik Jari Matriks dan Deteksi Manipulasi</h3>
<ul align="justify">
<li><b>Transformasi Matriks ke Representasi Byte:</b><br>
Matriks diubah menjadi string byte untuk memungkinkan perhitungan sidik jari melalui SHA-256.</li>
<li>
    <b>Fungsi Hash</b> $H : \{0,1\}^{*}\to \{0,1\}^{256}$: <br>
    Hash SHA-256 digunakan sebagai <b>sidik jari unik</b> matriks publik yang dikirim, untuk deteksi 
    integritas dan serangan manipulasi oleh Eve.
</li>
</ul>

<h3>5ï¸âƒ£ Pertukaran Kunci dan Derivasi Kunci Sesi</h3>
<ul align="justify">
<li><b>Kunci Privat dan Publik</b>: <br>
    Alice dan Bob masing-masing memiliki <b>kunci privat skalar</b> $a$ dan $b$ serta menghasilkan <b>kunci publik matriks</b>
    $A_{\text{pub}} = a\cdot G_{\text{Alice}} \mod p$ dan $B_{\text{pub}} = b\cdot G_{\text{Bob}} \mod p$. Matriks 
    generator $G$ bernoise.
</li>
<li>
    <b>Kunci Bersama (Shared Secret)</b>: Alice menghitung <b>$S_A = a\cdot B_{\text{pub}}  \mod p$</b>
    dan Bob menghitung <b>$S_B = b\cdot A_{\text{pub}}  \mod p$</b>. Karena $ab=ba$, maka $S_A=S_B$.
</li>
<li><b>Derivasi Kunci Sesi</b>: Menggabungkan <i>shared secret</i>, <i>nonce</i>, <i>timestamp</i>, dan <i>sidik jari</i>, 
    lalu di-hash menjadi kunci sesi sepanjang 256 bit.</li>
</ul>

<h3>6ï¸âƒ£ Simulasi Serangan Eve</h3>
<p align="justify">
Dengan probabilitas <b>$P_{\text{Eve}}$</b>, Eve dapat mencegat komunikasi, mengganti kunci publik Bob, 
dan mencoba menyusup. Sidik jari diverifikasi untuk mendeteksi manipulasi ini.
</p>

<h3>7ï¸âƒ£ Enkripsi dan Dekripsi Pesan</h3>
<ul align="justify">
<li>
    Pesan terenkripsi menggunakan <b>operasi XOR</b> sederhana dengan kunci sesi:
    $$
    C=M\oplus K\quad \text{dan}\quad M=C\oplus K.
    $$
    Di mana $M$ adalah pesan asli, $K$ adalah kunci sesi hasil derivasi, dan $C$ adalah pesan terenkripsi.
</li>
<li>Keamanan tetap terjaga selama kunci sesi memiliki entropi tinggi dan unik.</li>
</ul>

<h3>8ï¸âƒ£ Eksperimen dan Statistik</h3>
<p align="justify">
Simulasi diulang beberapa kali untuk menghitung statistik kegagalan, tingkat deteksi serangan, serta dampak tingkat noise dan probabilitas serangan terhadap keandalan sistem.
</p>

<h3>9ï¸âƒ£ Kesimpulan Matematika</h3>
<ul align="justify">
<li>Menggabungkan konsep <b>modular arithmetic</b>, <b>aljabar matriks</b>, dan <b>hashing</b>.</li>
<li>Model probabilistik memberikan simulasi realistis terkait potensi ancaman pihak ketiga.</li>
<li>Teknik derivasi kunci memperkuat kerahasiaan meskipun komunikasi melalui kanal yang bising atau tidak aman.</li>
</ul>

<hr>
<p align="justify">
    <i><b>Catatan:</b></i> Simulasi ini bukan skema kriptografi yang siap pakai untuk dunia nyata, melainkan 
    ilustrasi edukatif konsep-konsep matematika dalam keamanan informasi.
</p>

<script src="https://sagecell.sagemath.org/static/embedded_sagecell.js"></script>
<script>
    sagecell.makeSagecell({
        inputLocation: "#sagemath-ecc4",
        template: sagecell.templates.default,    
        evalButtonText: "â–¶ï¸ Jalankan Simulasi"
    });
</script>

<div id="sagemath-ecc4">
<textarea>
import numpy as np
from hashlib import sha256
from time import time
import os
# from sage.all import * # Mengomentari ini jika tidak diperlukan lagi

# --- PERUBAHAN UTAMA: MODULUS YANG LEBIH BESAR ---
modulus = 65537 # Bilangan prima yang lebih besar untuk keamanan yang lebih baik dalam simulasi
n = 8
peluang_eve = 0.5

G = np.random.randint(1, modulus, size=(n, n), dtype=np.int64)

def matrix_to_bytes(M):
    byte_list = []
    # Mengonversi nilai ke rentang byte [0, 255]
    # Penting: Pastikan nilai dalam M sudah modulo 211
    # Jika modulus > 255, kita tidak bisa langsung memetakan semua nilai ke 1 byte.
    # Untuk modulus yang lebih besar, kita perlu strategi encoding yang berbeda.
    # Namun, jika kita hanya ingin menggunakan hash dari nilai-nilai itu,
    # maka kita akan hash nilai aslinya, bukan representasi byte per elemen.
    
    # Pendekatan: Konversi seluruh matriks menjadi satu string byte yang besar.
    # Misalnya, dengan mengonversi setiap int ke string dan encode.
    # ATAU, jika kita tetap ingin elemen per byte (seperti sebelumnya),
    # kita harus melakukan modulo 256 secara eksplisit pada setiap nilai.
    
    # Mari kita asumsikan untuk sidik jari, kita hash representasi integer dari setiap elemen.
    # Jika elemen matriks M sekarang bisa mencapai 65536, itu tidak bisa masuk ke 1 byte.
    # Solusinya adalah mengubah cara matrix_to_bytes bekerja:
    # Menggabungkan semua elemen menjadi satu byte string besar.
    
    # Pendekatan paling robust: konversi setiap elemen ke string dan encode, lalu gabungkan.
    # Ini akan membuat fingerprint unik untuk nilai-nilai yang lebih besar.
    data_str = ""
    for i in range(M.shape[0]):
        for j in range(M.shape[1]):
            data_str += str(int(M[i, j])) + "," # Konversi ke string dan tambahkan pemisah
    return data_str.encode('utf-8') # Encode seluruh string menjadi bytes

# Catatan: Fungsi matrix_to_bytes di atas diubah karena modulus > 255.
# Sebelumnya, kita asumsikan setiap elemen matriks bisa diwakili 1 byte.
# Dengan modulus 65537, elemen bisa mencapai 65536.
# Jadi, kita tidak lagi mengonversi `M[i,j] % 256` untuk byte per elemen,
# melainkan mengonversi nilai integer asli ke string dan menggabungkannya.
# Ini penting untuk sidik jari yang akurat dari matriks bernilai besar.

def sidik_jari(M):
    data = matrix_to_bytes(M)
    return sha256(data).hexdigest()

def tambahkan_noise(M, current_noise_level):
    noisy = M.copy()
    
    noise_values = np.random.uniform(-current_noise_level * modulus * 0.5, 
                                     current_noise_level * modulus * 0.5, 
                                     size=(n, n))
    
    mask = np.random.uniform(0, 1, size=(n, n)) < current_noise_level
    
    noisy[mask] = (noisy[mask].astype(np.int64) + noise_values[mask].astype(np.int64)) % modulus
    
    noisy[noisy < 0] += modulus

    return noisy.astype(np.int64)

def derive_key(shared_secret_bytes, salt_bytes, info=b"key_derivation"):
    if not isinstance(shared_secret_bytes, bytes):
        shared_secret_bytes = str(shared_secret_bytes).encode('utf-8')
    if not isinstance(salt_bytes, bytes):
        salt_bytes = str(salt_bytes).encode('utf-8')
    if not isinstance(info, bytes):
        info = str(info).encode('utf-8')

    combined = shared_secret_bytes + salt_bytes + info
    return sha256(combined).digest()[:32]

def simple_xor_encrypt(msg_bytes, key_bytes):
    if not isinstance(msg_bytes, bytes):
        raise TypeError("msg_bytes must be bytes")
    if not isinstance(key_bytes, bytes):
        raise TypeError("key_bytes must be bytes")
    
    msg_arr = np.frombuffer(msg_bytes, dtype=np.uint8)
    key_arr = np.frombuffer(key_bytes, dtype=np.uint8)
    
    repeated_key = np.resize(key_arr, len(msg_arr)) 
    
    encrypted_arr = np.bitwise_xor(msg_arr, repeated_key)
    return encrypted_arr.tobytes()

def simple_xor_decrypt(enc_bytes, key_bytes):
    if not isinstance(enc_bytes, bytes):
        raise TypeError("enc_bytes must be bytes")
    if not isinstance(key_bytes, bytes):
        raise TypeError("key_bytes must be bytes")

    enc_arr = np.frombuffer(enc_bytes, dtype=np.uint8)
    key_arr = np.frombuffer(key_bytes, dtype=np.uint8)

    repeated_key = np.resize(key_arr, len(enc_arr))
    
    decrypted_arr = np.bitwise_xor(enc_arr, repeated_key)
    return decrypted_arr.tobytes()

def proses_simulasi_aman(pesan_input, current_noise_level, verbose=True):
    try:
        private_a = np.random.randint(1, modulus)
        private_b = np.random.randint(1, modulus)
        private_e = np.random.randint(1, modulus)
        
        G_alice = tambahkan_noise(G, current_noise_level)
        G_bob = tambahkan_noise(G, current_noise_level)
        G_eve = tambahkan_noise(G, current_noise_level)

        nonce_bytes = os.urandom(8)
        nonce_int = int.from_bytes(nonce_bytes, byteorder='big') 
        
        timestamp = int(time())

        A_pub = (private_a * G_alice) % modulus
        B_pub = (private_b * G_bob) % modulus
        E_pub = (private_e * G_eve) % modulus

        sidik_A = sidik_jari(A_pub)
        sidik_B_asli = sidik_jari(B_pub)
        sidik_E = sidik_jari(E_pub)

        komunikasi_digagalkan = False

        manipulasi = uniform(0, 1) < peluang_eve
        
        if manipulasi:
            B_pub_terima = E_pub
            sidik_B_terima = sidik_jari(B_pub_terima)
            if verbose:
                show(html("<p style='color:orange'><b>ğŸ•µï¸â€â™€ï¸ Simulasi: Eve berhasil mencegat dan mengganti Kunci Publik Bob!</b></p>"))
                show(html(f"<p style='color:orange'>Sidik Bob Asli: {sidik_B_asli[:16]}... vs Sidik Bob Diterima (Eve): {sidik_B_terima[:16]}...</p>"))
        else:
            B_pub_terima = B_pub
            sidik_B_terima = sidik_jari(B_pub_terima)
            if verbose:
                show(html("<p style='color:green'><b>âœ… Simulasi: Komunikasi tidak dimanipulasi oleh Eve.</b></p>"))

        if sidik_B_asli != sidik_B_terima:
            if verbose:
                show(html("<p style='color:red'><b>ğŸ›¡ï¸ğŸ§  DETEKSI SERANGAN BERHASIL: Sidik jari Bob tidak cocok! Komunikasi dibatalkan.</b></p>"))
            komunikasi_digagalkan = True
            return komunikasi_digagalkan

        shared_secret = (private_a * B_pub_terima) % modulus
        # shared_secret_bytes = matrix_to_bytes(shared_secret) # Ini tidak lagi dipakai untuk session key
        
        # Untuk derive_key, shared_secret_bytes harus benar-benar merepresentasikan secret itu sendiri.
        # Jika shared_secret bisa memiliki nilai hingga 65536, kita tidak bisa langsung matrix_to_bytes
        # ke byte per elemen. Jadi, kita akan hash representasi string dari matriks.
        shared_secret_bytes_for_kdf = str(shared_secret.flatten()).encode('utf-8')
        
        salt_bytes = b"Nonce:" + nonce_bytes + b" Timestamp:" + str(timestamp).encode('utf-8') + \
                     b" SidikA:" + sidik_A.encode('utf-8') + b" SidikB:" + sidik_B_terima.encode('utf-8')
        
        # Kunci sesi kini berasal dari representasi string matriks rahasia
        session_key = derive_key(shared_secret_bytes_for_kdf, salt_bytes)

        pesan_bytes = pesan_input.encode('utf-8')
        encrypted_bytes = simple_xor_encrypt(pesan_bytes, session_key)
        decrypted_bytes = simple_xor_decrypt(encrypted_bytes, session_key)
        pesan_terdekripsi = decrypted_bytes.decode('utf-8')

        if verbose and not komunikasi_digagalkan:
            show(html(f"""
            <h3>ğŸ”’ Komunikasi Aman</h3>
            <ul>
              <li><b>Nonce (Integer):</b> {nonce_int}</li>
              <li><b>Timestamp:</b> {timestamp}</li>
              <li><b>Sidik jari Alice:</b> {sidik_A[:16]}...</li>
              <li><b>Sidik jari Bob (diterima):</b> {sidik_B_terima[:16]}...</li>
              <li><b>Kunci sesi (hex, sebagian):</b> {session_key.hex()[:16]}...</li>
            </ul>
            <p><b>Pesan asli:</b> {pesan_input}</p>
            <p><b>Pesan terenkripsi:</b><br><code>{encrypted_bytes.hex()}</code></p>
            <p><b>Pesan terdekripsi:</b> {pesan_terdekripsi}</p>
            """))

        if pesan_input != pesan_terdekripsi and not komunikasi_digagalkan:
            if verbose:
                show(html("<p style='color:red'><b>ğŸš«ğŸ”“ DEKRIPSI GAGAL: Pesan tidak cocok meskipun tidak ada serangan terdeteksi!</b></p>"))
            komunikasi_digagalkan = True
            
        return komunikasi_digagalkan

    except Exception as e:
        show(html(f"<p style='color:red'><b>ğŸ’¥ Error di proses_simulasi_aman:</b> {e}</p>"))
        return True

@interact
def _(pesan=input_box(default="Pesan rahasia kita ğŸ’– Untuk Bob!", label="ğŸ“© Pesan Alice", type=str, rows=6),
      kirim=checkbox(False, label="âœ… Kirim Pesan?"),
      banyak=slider(1, 1000, 1, default=10, label="ğŸ”ğŸ§ª Ulangi Percobaan"),
      noise=slider(0.0, 1.0, 0.05, default=0.3, label="ğŸšï¸ Tingkat Noise (0.0-1.0)"),
      peluang=slider(0.0, 1.0, 0.05, default=0.5, label="ğŸ‘ï¸â€ğŸ—¨ï¸Â­ Peluang Eve Menyerang (0.0-1.0)")):

    if kirim:
        bocor = 0
        for _ in range(banyak):
            if proses_simulasi_aman(pesan, noise, verbose=(banyak == 1)):
                bocor += 1

        if banyak > 1:
            tingkat = bocor / banyak
            tingkat_float = float(tingkat) * 100
            warna = "green" if tingkat_float < 1 else "orange" if tingkat_float < 10 else "red"

            show(html(f"""
            <h3>ğŸ“Š Statistik Serangan Eve</h3>
            <ul>
              <li><b>Total percobaan:</b> {banyak}</li>
              <li><b>Jumlah komunikasi gagal/bocor:</b> {bocor}</li>
              <li><b>Tingkat kegagalan:</b> <span style="color:{warna}"><b>{tingkat_float:.2f}%</b></span></li>
              <li><b>Tingkat Noise yang Digunakan:</b> {noise:.2f}</li>
              <li><b>Peluang Eve Menyerang:</b> {peluang:.2f}</li>
            </ul>
            """))   
</textarea>
</div>
<hr>
<p align="justify">
Berikut ini kita sajikan Sel SageMath yang bisa anda gunakan sebagai media latihan dalam bereksperimen baik dengan Sage
atau Python.
</p>

<script src="https://sagecell.sagemath.org/static/embedded_sagecell.js"></script>
<script>
    sagecell.makeSagecell({
        inputLocation: "#latihan",
        template: sagecell.templates.default,    
        evalButtonText: "ğŸ” Jalankan Kode",
        languages:['sage','python']
    });
</script>

<div id="latihan">
<textarea>
# Silahkan bereksperimen disini dengan Sage atau Python,
# untuk memulai tekan tombol Enter lalu ketik: help() dan tekan tombol Jalankan Kode.

</textarea>
</div>
<hr>
<script src="https://sagecell.sagemath.org/static/embedded_sagecell.js"></script>
<script>
    sagecell.makeSagecell({
        inputLocation: "#latihan1",
        template: sagecell.templates.default,    
        evalButtonText: "ğŸ” Jalankan Kode",
        languages:['sage','python']
    });
</script>

<div id="latihan1">
<textarea>
# Silahkan ketik disini kode Sage atau Python!

</textarea>
</div>
<hr>
<script src="https://sagecell.sagemath.org/static/embedded_sagecell.js"></script>
<script>
    sagecell.makeSagecell({
        inputLocation: "#latihan2",
        template: sagecell.templates.default,    
        evalButtonText: "ğŸ” Jalankan Kode",
        languages:['sage','python']
    });
</script>

<div id="latihan2">
<textarea>
# Silahkan ketik disini kode Sage atau Python!

</textarea>
</div>
<hr>
<script src="https://sagecell.sagemath.org/static/embedded_sagecell.js"></script>
<script>
    sagecell.makeSagecell({
        inputLocation: "#latihan3",
        template: sagecell.templates.default,    
        evalButtonText: "ğŸ” Jalankan Kode",
        languages:['sage','python']
    });
</script>

<div id="latihan3">
<textarea>
# Silahkan ketik disini kode Sage atau Python!

</textarea>
</div>
</details>
</details>
</section>

  <div class="horizontal-menu">
        <button class="btn" onclick="addTextBlock(this)">â• Teks LaTeX</button>
        <button class="btn" onclick="addMathliveBlock(this)">â• MathLive</button>
        <button class="btn" onclick="addSageCell(this)">â• SageMath</button>
        <button class="btn save-all-btn" id="saveBtn6">ğŸ’¾ Simpan Semua</button>
        <button class="btn import-btn" data-target="importFile6">ğŸ“‚ Impor File</button>
        <input type="file" id="importFile6" accept=".json" style="display:none"; />
        <button class="btn" onclick="localStorage.clear(); alert('Data lokal dibersihkan!')">ğŸ§¹ Bersihkan Data</button>
    </div>
</div>
<hr>



<script>
// Objek global untuk menyimpan instance CodeMirror atau SageCell
const sageCellInstances = new Map(); 

// --- FUNGSI PEMBUAT ELEMEN BLOCK (MODULAR) ---

function createBlockHeader(titleText, deleteBtnAction) {
    const header = document.createElement("div");
    header.className = "block-header";
    const title = document.createElement("span");
    title.textContent = titleText;
    header.appendChild(title);
    
    const deleteBtn = document.createElement("button");
    deleteBtn.className = "btn btn-small btn-delete";
    deleteBtn.textContent = "ğŸ—‘ Hapus";
    deleteBtn.onclick = () => deleteBlock(deleteBtn);
    header.appendChild(deleteBtn);
    
    return header;
}

function createTextBlockElement(content = '', idOverride = '', previewShown = false, titleText = 'Blok Teks LaTeX') {
    const block = document.createElement("div");
    block.className = "text-block";
    block.appendChild(createBlockHeader(titleText));

    const ta = document.createElement("textarea");
    const prev = document.createElement("div");
    prev.className = "preview";
    const uniqueId = idOverride || `editor-${Date.now()}`;
    ta.id = uniqueId;
    prev.id = "preview-" + uniqueId;
    ta.value = content;
    prev.style.display = previewShown ? "block" : "none";
    ta.style.display = previewShown ? "none" : "block";

    ta.addEventListener("input", () => {
        renderMath(ta, prev);
        saveBlockState(ta.id, ta.value, previewShown);
    });

    const toggleBtn = document.createElement("button");
    toggleBtn.className = "btn-small";
    toggleBtn.textContent = previewShown ? "â†”ï¸ Edit Teks" : "â†”ï¸ Lihat Pratinjau";
    toggleBtn.onclick = () => {
        toggleEditPreview(toggleBtn, ta.id, prev.id);
        saveBlockState(ta.id, ta.value, previewEl.style.display !== 'none');
    };
    
    block.appendChild(ta);
    block.appendChild(prev);
    block.appendChild(toggleBtn);

    if (previewShown) {
        renderMath(ta, prev);
    }
    
    return block;
}

function createMathliveBlockElement(content = '', idOverride = '') {
    const block = document.createElement("div");
    block.className = "mathlive-block";
    block.appendChild(createBlockHeader("Blok MathLive"));

    const mf = document.createElement("math-field");
    mf.setAttribute("virtual-keyboard-mode", "onfocus");
    const uniqueId = idOverride || `mathlive-${Date.now()}`;
    mf.id = uniqueId;
    mf.value = content;
    mf.addEventListener("input", () => saveBlockState(mf.id, mf.value));
    
    block.appendChild(mf);
    
    return block;
}

function createSageCellElement(content = '') {
    const block = document.createElement("div");
    block.className = "sage-block";

    const header = createBlockHeader("Blok SageMath");
    const docsLink = document.createElement("a");
    docsLink.href = "https://doc.sagemath.org/";
    docsLink.target = "_blank";
    docsLink.className = "docs-link";
    docsLink.textContent = "ğŸ“š Dokumentasi SageMath";
    header.appendChild(docsLink);

    const copyToLatexBtn = document.createElement("button");
    copyToLatexBtn.className = "btn btn-small";
    copyToLatexBtn.textContent = "â• Blok Kode LaTeX Baru";
    copyToLatexBtn.onclick = () => addTextBlock(document.querySelector('.horizontal-menu'), '', '', false, 'Blok Kode LaTeX');
    header.appendChild(copyToLatexBtn);
    block.appendChild(header);

    const sageInput = document.createElement("div");
    sageInput.className = "sagecell_input";
    const sageOutput = document.createElement("div");
    sageOutput.className = "sagecell_output";

    const textarea = document.createElement("textarea");
    textarea.style.display = 'none';
    textarea.value = content;
    sageInput.appendChild(textarea);

    block.appendChild(sageInput);
    block.appendChild(sageOutput);
    
    block.postInitialization = () => {
        sagecell.makeSagecell({
            inputLocation: sageInput,
            outputLocation: sageOutput,
            evalButtonText: 'Jalankan',
			languages: ['sage', 'python'], // Menambahkan 'python' sebagai pilihan bahasa
            code: content,
            autoeval: content.trim() !== ''
        });
    };
    
    return block;
}

// --- FUNGSI TAMBAH DAN MANIPULASI BLOCK (API UTAMA) ---

function renderMath(inputEl, outputEl) {
    outputEl.innerHTML = inputEl.value;
    MathJax.typesetPromise([outputEl]);
}

function toggleEditPreview(button, editorId, previewId) {
    const editorEl = document.getElementById(editorId);
    const previewEl = document.getElementById(previewId);
    if (editorEl.style.display === "none") {
        editorEl.style.display = "block";
        previewEl.style.display = "none";
        button.textContent = "â†”ï¸ Lihat Pratinjau";
    } else {
        editorEl.style.display = "none";
        previewEl.style.display = "block";
        button.textContent = "â†”ï¸ Edit Teks";
        renderMath(editorEl, previewEl);
    }
}

function deleteBlock(element) {
    if (confirm("Apakah Anda yakin ingin menghapus blok ini?")) {
        const blockToRemove = element.closest('.text-block, .mathlive-block, .sage-block');
        if (blockToRemove.classList.contains('text-block')) {
            const textarea = blockToRemove.querySelector('textarea');
            if (textarea && textarea.id) {
                localStorage.removeItem(textarea.id);
            }
        } else if (blockToRemove.classList.contains('mathlive-block')) {
            const mathfield = blockToRemove.querySelector('math-field');
            if (mathfield && mathfield.id) {
                localStorage.removeItem(mathfield.id);
            }
        }
        blockToRemove.remove();
    }
}

function addTextBlock(button, content = '', idOverride = '', previewShown = false, titleText = 'Blok Teks LaTeX') {
    const parentMenu = button.closest('.horizontal-menu');
    const block = createTextBlockElement(content, idOverride, previewShown, titleText);
    parentMenu.insertAdjacentElement('afterend', block);
    const textarea = block.querySelector('textarea');
    if (previewShown) {
        renderMath(textarea, block.querySelector('.preview'));
    }
    // Simpan ke localStorage saat blok dibuat
    saveBlockState(textarea.id, textarea.value, previewShown);
}

function addMathliveBlock(button, content = '', idOverride = '') {
    const parentMenu = button.closest('.horizontal-menu');
    const block = createMathliveBlockElement(content, idOverride);
    parentMenu.insertAdjacentElement('afterend', block);
    // Simpan ke localStorage saat blok dibuat
    saveBlockState(block.querySelector('math-field').id, content);
}

function addSageCell(button, content = '') {
    const parentMenu = button.closest('.horizontal-menu');
    const block = createSageCellElement(content);
    parentMenu.insertAdjacentElement('afterend', block);
    block.postInitialization();
    // Sage block tidak disimpan di localStorage per item, hanya saat saveSession
}

function saveBlockState(id, content, previewShown = false) {
    const state = { content: content, previewShown: previewShown };
    localStorage.setItem(id, JSON.stringify(state));
}

// --- FUNGSI SIMPAN & MUAT SESI (FILE) ---

function saveSession() {
    const blocks = document.querySelectorAll('.text-block, .mathlive-block, .sage-block');
    const sessionData = [];

    blocks.forEach(block => {
        let type, content, id, previewShown;
        
        if (block.classList.contains('text-block')) {
            type = 'text';
            const textarea = block.querySelector('textarea');
            content = textarea ? textarea.value : '';
            id = textarea ? textarea.id : `text-${Date.now()}`;
            const previewEl = block.querySelector('.preview');
            previewShown = previewEl ? previewEl.style.display !== 'none' : false;
        } else if (block.classList.contains('mathlive-block')) {
            type = 'mathlive';
            const mathfield = block.querySelector('math-field');
            content = mathfield ? mathfield.value : '';
            id = mathfield ? mathfield.id : `mathlive-${Date.now()}`;
        } else if (block.classList.contains('sage-block')) {
            type = 'sage';
            // Dapatkan konten Sage dari instance CodeMirror jika ada
            const editorDiv = block.querySelector('.CodeMirror');
            if (editorDiv && editorDiv.CodeMirror) {
                content = editorDiv.CodeMirror.getValue();
            } else {
                const textarea = block.querySelector('textarea');
                content = textarea ? textarea.value : '';
            }
            id = `sage-${Date.now()}`;
        }
        
        if (content && content.trim() !== '') {
            sessionData.push({ type, content, id, previewShown });
        }
    });
    
    if (sessionData.length === 0) {
        alert("Tidak ada konten yang bisa disimpan.");
        return;
    }

    const dataStr = JSON.stringify(sessionData, null, 2);
    const blob = new Blob([dataStr], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `matematika_interaktif_${new Date().toISOString()}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    alert('Sesi berhasil disimpan!');
}

function loadSession(file, importButton) {
    if (!file) {
        return;
    }

    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const sessionData = JSON.parse(e.target.result);
            const parentMenu = importButton.closest('.horizontal-menu');

            let lastBlockElement = parentMenu;
            sessionData.forEach(blockData => {
                let newBlock;
                if (blockData.type === 'text') {
                    newBlock = createTextBlockElement(blockData.content, blockData.id, blockData.previewShown);
                    lastBlockElement.insertAdjacentElement('afterend', newBlock);
                    lastBlockElement = newBlock;
                    if (blockData.previewShown) {
                        renderMath(newBlock.querySelector('textarea'), newBlock.querySelector('.preview'));
                    }
                } else if (blockData.type === 'mathlive') {
                    newBlock = createMathliveBlockElement(blockData.content, blockData.id);
                    lastBlockElement.insertAdjacentElement('afterend', newBlock);
                    lastBlockElement = newBlock;
                } else if (blockData.type === 'sage') {
                    newBlock = createSageCellElement(blockData.content);
                    lastBlockElement.insertAdjacentElement('afterend', newBlock);
                    lastBlockElement = newBlock;
                    newBlock.postInitialization();
                }
            });
            alert('Sesi berhasil dimuat!');
        } catch (error) {
            alert('Gagal memuat sesi. Pastikan file yang diimpor benar.');
            console.error('Error saat memuat sesi:', error);
        }
    };
    reader.readAsText(file);
}

// --- SETUP EVENT LISTENER UTAMA ---

document.addEventListener('DOMContentLoaded', () => {
    // Event listener untuk tombol Simpan Semua
    const saveButtons = document.querySelectorAll('.save-all-btn');
    saveButtons.forEach(button => {
        button.addEventListener('click', saveSession);
    });

    // Event listener untuk tombol Impor File
    const importButtons = document.querySelectorAll('.import-btn');
    importButtons.forEach(button => {
        const fileInputId = button.dataset.target;
        const fileInput = document.getElementById(fileInputId);

        button.addEventListener('click', () => {
            fileInput.click();
        });

        fileInput.addEventListener('change', (event) => {
            const selectedFile = event.target.files[0];
            if (selectedFile) {
                // Panggil loadSession dengan file dan tombol impor sebagai argumen
                loadSession(selectedFile, button); 
            }
        });
    });
});
</script>

</body>
</html>
